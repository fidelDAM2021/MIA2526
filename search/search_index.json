{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"CE IA i Big Data Curs 25/26","text":""},{"location":"#models-dintelligencia-artificial","title":"Models d'Intel\u00b7lig\u00e8ncia Artificial","text":"<ul> <li>0. Presentaci\u00f3</li> <li>1. Introducci\u00f3 a la Intel\u00b7lig\u00e8ncia Artificial</li> <li>2. Introducci\u00f3 als Models d'Intel\u00b7lig\u00e8ncia Artificial</li> <li>3.1 Soluci\u00f3 de problemes de cerca</li> </ul>"},{"location":"documents/","title":"Presentaci\u00f3 del m\u00f2dul Models d'Intel\u00b7lig\u00e8ncia Artificial (MIA)","text":"Professor: Fidel Oltra Contacte: jf.oltralandete@edu.gva.es"},{"location":"documents/#descripcio-del-modul-mia","title":"Descripci\u00f3 del m\u00f2dul MIA","text":"<p>El m\u00f2dul de Models d'Intel\u00b7lig\u00e8ncia Artificial (MIA) forma part del Curs d'Especialitzaci\u00f3 en IA i Big Data (IABD) i t\u00e9 una durada de 90 hores. El m\u00f2dul est\u00e0 dissenyat per proporcionar als estudiants els coneixements i habilitats necessaris per identificar, dissenyar i implementar models d'intel\u00b7lig\u00e8ncia artificial en diferents \u00e0mbits d'aplicaci\u00f3.</p>"},{"location":"documents/#temporalitzacio","title":"Temporalitzaci\u00f3","text":"<p>3 hores a la setmana al llarg de 30 setmanes.</p> <p>Dimarts: 16:25 - 18:15  Dijous: 18:45 - 19:40</p>"},{"location":"documents/#objectius","title":"Objectius","text":"<p>Els objectius generals del Curs d'Especialitzaci\u00f3 en IA i Big Data se concreten, en cada m\u00f2dul, en els seus Resultats d'Aprenentatge (RA) i Criteris d'Avaluaci\u00f3 (CA) que se detallen en la programaci\u00f3 del m\u00f2dul.</p> <p>Els Resultats d'Aprenentatge (RA) espec\u00edfics del m\u00f2dul MIA s\u00f3n:</p> <ul> <li> <p>RA1: Caracteritza sistemes d'Intel\u00b7lig\u00e8ncia Artificial relacionant-los amb la millora de l'efici\u00e8ncia operativa de les organitzacions i empreses.</p> </li> <li> <p>RA2: Utilitza models de sistemes d'Intel\u00b7lig\u00e8ncia Artificial implementant sistemes de resoluci\u00f3 de problemes.</p> </li> <li> <p>RA3: Relaciona el processament de llenguatge natural amb les seues aplicacions, determinant el seu potencial i identificant les seues limitacions.</p> </li> <li> <p>RA4: Analitza sistemes robotitzats, avaluant opcions de disseny i implementaci\u00f3.</p> </li> <li> <p>RA5: Aplica sistemes experts avaluant la influ\u00e8ncia dels controladors intel\u00b7ligents en el comportament del sistema.</p> </li> <li> <p>RA6: Aplica principis legals i \u00e8tics al desenvolupament de la Intel\u00b7lig\u00e8ncia Artificial integrant-los com a part del proc\u00e9s.</p> </li> </ul>"},{"location":"documents/#competencies-professionals","title":"Compet\u00e8ncies professionals","text":"<ul> <li> <p>a) Aplicar sistemes d'Intel\u00b7lig\u00e8ncia Artificial per identificar noves formes d'interacci\u00f3 en els negocis que milloren la productivitat.</p> </li> <li> <p>b) Desenvolupar i implementar sistemes d\u2019intel\u00b7lig\u00e8ncia artificial que faciliten la presa de decisions \u00e0gils dins d\u2019un negoci gestionant i explotant dades massives.</p> </li> <li> <p>c) Gestionar la transformaci\u00f3 digital necess\u00e0ria a les organitzacions per a la consecuci\u00f3 de l\u2019efici\u00e8ncia empresarial mitjan\u00e7ant el tractament de dades.</p> </li> <li> <p>d) Aplicar Intel\u00b7lig\u00e8ncia Artificial en funcionalitats, processos i sistemes de decisi\u00f3 empresarials.</p> </li> <li> <p>e) Gestionar els diferents tipus d'Intel\u00b7lig\u00e8ncia Artificial per a la consecuci\u00f3 de transformaci\u00f3 i canvi en les empreses.</p> </li> <li> <p>j) Executar el sistema d\u2019explotaci\u00f3 de dades segons les necessitats d\u2019\u00fas i les condicions de seguretat establertes assegurant el compliment dels principis legals i \u00e8tics.</p> </li> <li> <p>k) Configurar les eines que es fan servir per construir solucions Big Data i d\u2019Intel\u00b7lig\u00e8ncia Artificial.</p> </li> </ul>"},{"location":"documents/#continguts","title":"Continguts","text":"<p>Els continguts d\u2019aquest m\u00f2dul professional, segons estableix el curr\u00edculum vigent, s\u00f3n els seg\u00fcents:</p> <ul> <li> <p>C1. Caracteritzaci\u00f3 de Sistemes d'Intel\u00b7lig\u00e8ncia Artificial.</p> </li> <li> <p>C2. Utilitzaci\u00f3 de Models d'Intel\u00b7lig\u00e8ncia Artificial.</p> </li> <li> <p>C3. Processament del llenguatge natural.</p> </li> <li> <p>C4. An\u00e0lisi de sistemes robotitzats.</p> </li> <li> <p>C5. Sistemes experts.</p> </li> <li> <p>C6. Aplicaci\u00f3 de principis legals i \u00e8tics de la Intel\u00b7lig\u00e8ncia Artificial.</p> </li> </ul>"},{"location":"documents/#unitats-de-programacio","title":"Unitats de programaci\u00f3","text":"<p>UP01: Introducci\u00f3 a la Intel\u00b7lig\u00e8ncia Artificial. UP02: Models d'Intel\u00b7lig\u00e8ncia Artificial. UP03: Algorismes de cerca. UP04: Processament del llenguatge natural. UP05: Sistemes experts. UP06: Sistemes robotitzats. UP07: \u00c8tica i legislaci\u00f3.</p>"},{"location":"documents/#metodologia","title":"Metodologia","text":"<ul> <li> <p>Apunts, exemples, pr\u00e0ctiques i documentaci\u00f3 en la plataforma Aules.</p> </li> <li> <p>Aprenentatge basat en Reptes (ABR) i Projectes (ABP), mitjan\u00e7ant el desenvolupament primer de reptes m\u00e9s concrets i, m\u00e9s endavant, de projectes intermodulars reals complets, proposats, sempre que siga possible, en col\u00b7laboraci\u00f3 amb empreses i organitzacions.</p> </li> <li> <p>Aprenentatge col\u00b7laboratiu, en els propis projectes i reptes, que s'abordaran mitjan\u00e7ant el treball en equip i amb eines de gesti\u00f3 de projectes.</p> </li> <li> <p>Classe invertida (Flipped Classroom), on l'alumnat treballa els continguts pel seu compte, i aprofita els problemes que va trobant al llarg del desenvolupament dels projectes i reptes, o en la resoluci\u00f3 d'exercicis, per preguntar a l'aula els seus dubtes. La classe per tant esdev\u00e9 un espai de resoluci\u00f3 de dubtes i d'aplicaci\u00f3 pr\u00e0ctica dels continguts.</p> </li> </ul>"},{"location":"u01/","title":"Introducci\u00f3 a la intel\u00b7lig\u00e8ncia Artificial","text":"<p>En esta primera unitat anem a introduir conceptes b\u00e0sics sobre intel\u00b7lig\u00e8ncia artificial i models d'IA. La introducci\u00f3 ser\u00e0 comuna als m\u00f2duls de Models d'Intel\u00b7lig\u00e8ncia Artificial i Sistemes d'Aprenentatge Autom\u00e0tic, per la qual cosa molts conceptes es repetiran en ambd\u00f3s m\u00f2duls.</p>"},{"location":"u01/#definicio-i-conceptes-basics","title":"Definici\u00f3 i conceptes b\u00e0sics","text":"<p>Una primera definici\u00f3 d'intel\u00b7lig\u00e8ncia artificial (IA) podria ser la seg\u00fcent: habilitat per aprendre i resoldre problemes duta a terme per una m\u00e0quina o programari.</p> <p>Si entenem com IA la capacitat d'una m\u00e0quina per a simular processos d'intel\u00b7lig\u00e8ncia humana, podem establir almenys tres punts clau:</p> <ul> <li>Aprenentatge: La IA ha de ser capa\u00e7 d'aprendre de l'experi\u00e8ncia, tant inicialment a partir d'unes regles / dades inicials, com millorant el seu rendiment a mesura que s'exposa a m\u00e9s dades o situacions (autocorrecci\u00f3).</li> <li>Raonament: La IA ha de ser capa\u00e7 de raonar i prendre decisions basades en la informaci\u00f3 disponible, utilitzant l\u00f2gica i coneixements previs.</li> <li>Resoluci\u00f3 de problemes: La IA ha de ser capa\u00e7 de resoldre problemes complexos i adaptar-se a noves situacions, utilitzant estrat\u00e8gies i t\u00e8cniques adequades.</li> </ul> <p>Una m\u00e0quina intel\u00b7ligent, \u00e9s a dir, capa\u00e7 de realitzar les tasques dites anteriorment, seria un agent flexible que percep el seu entorn i porta a terme accions que maximitzen les seues possibilitats d'\u00e8xit en objectius i tasques concretes.</p> <p>El concepte d'intel\u00b7lig\u00e8ncia artificial (IA) no \u00e9s el mateix ara que fa, per exemple, 50 anys. En unes d\u00e8cades hem passat d'unes m\u00e0quines que eren capaces de realitzar c\u00e0lculs senzills a sistemes que poden aprendre, raonar i prendre decisions complexes. Els objectius tamb\u00e9 han anat canviat al llarg del temps. En un principi eren molt ambiciosos, per\u00f2 no existia la tecnologia necess\u00e0ria. Poc a poc els objectius s'han anat fent m\u00e9s realistes i adaptant-se a la tecnologia existent en cada moment. </p> <p>Aix\u00ed, des dels anys 60 hem passat d'un objectiu inicial que pretenia replicar el proc\u00e9s de la intel\u00b7lig\u00e8ncia humana, a uns altres m\u00e9s pragm\u00e0tics i concrets. Els avan\u00e7os que s'han produ\u00eft tant en el camp de la IA com en el hardware i software necessaris, han fet que tornem a mirar endavant amb m\u00e9s ambici\u00f3. La idea de crear m\u00e0quines que puguen pensar i actuar com humans ha evolucionat cap a la creaci\u00f3 de sistemes que poden aprendre i adaptar-se a noves situacions, processar grans volums de dades i resoldre problemes complexos de manera aut\u00f2noma, per\u00f2 sense perdre de vista la possibilitat d'arribar a que la IA puga raonar, aprendre i actuar con un \u00e9sser hum\u00e0; fins i tot, que puga superar les capacitats humanes en certes tasques.</p> <p>\u00c9s per aix\u00f2 que tenim, com veurem m\u00e9s endavant, diferents enfocaments i tipus d'intel\u00b7lig\u00e8ncia artificial, que van des de la IA feble, que es centra en tasques espec\u00edfiques i limitades, fins a la IA forta, que pret\u00e9n replicar la intel\u00b7lig\u00e8ncia humana en tota la seua complexitat.</p> <p>Fins i tot una eina com chatGPT, que sembla que sap fer de tot, \u00e9s realment una IA feble centrada b\u00e0sicament en una \u00fanica tasca: processament del llenguatge. Tornarem m\u00e9s endavant sobre este concepte.</p>"},{"location":"u01/#historia-i-evolucio-de-la-ia","title":"Hist\u00f2ria i evoluci\u00f3 de la IA","text":"<p>Encara que semble que la intel\u00b7lig\u00e8ncia artificial \u00e9s un concepte recent, les seues arrels es remunten a fa m\u00e9s de 70 anys. En esta unitat farem un rep\u00e0s breu de la hist\u00f2ria i l'evoluci\u00f3 de la IA, des dels seus inicis fins als avan\u00e7os m\u00e9s recents.</p> <ul> <li>1943: Warren McCulloch i Walter Pitts publiquen un article que proposa un model matem\u00e0tic per a les neurones, establint les bases de les xarxes neuronals. </li> <li>1950: Alan Turing proposa el Test de Turing, un criteri per a determinar si una m\u00e0quina pot exhibir un comportament intel\u00b7ligent indistinguible del d'un \u00e9sser hum\u00e0.</li> <li>1956: En la Confer\u00e8ncia de Dartmouth, John McCarthy, Marvin Minsky i altres investigadors defineixen el terme \"intel\u00b7lig\u00e8ncia artificial\" i estableixen les bases per a la investigaci\u00f3 en este camp.</li> <li>1958: Se desenvolupa el llenguatge de programaci\u00f3 LISP, que es converteix en un dels llenguatges m\u00e9s utilitzats en la investigaci\u00f3 d'IA. Tamb\u00e9 apareix el perceptr\u00f3n, un algorisme de xarxa neuronal proposat per Frank Rosenblatt per a reconeixement de patrons. Concretament, s'utilitzava per a recon\u00e8ixer formes simples i classificar imatges.</li> <li>1959: Desenvolupament dels primers sistemes d'IA que utilitzaven regles per a resoldre problemes matem\u00e0tics i demostrar certs teoremes.</li> <li>1960s: Se desenvolupen els primers sistemes d'IA especialitzats, com ELIZA, un programa de processament del llenguatge natural que simulava una conversa amb un terapeuta, ordinadors que juguen als escacs, sistemes que resolen problemes matem\u00e0tics... Sempre tasques molt espec\u00edfiques i limitades.</li> <li>1966-1970: els resultats estan per baix de les expectatives i es produeix un primer per\u00edode de desencantament amb la IA, conegut com \"l'hivern de la IA\". Els investigadors es donen compte que les expectatives inicials eren massa altes i que els avan\u00e7os s\u00f3n m\u00e9s lents del que s'esperava. Se reajusten els objectius.</li> <li>1970s: S'investiga en sistemes basats en el coneixement, com els sistemes experts, que utilitzaven regles i coneixements espec\u00edfics per a resoldre problemes en \u00e0rees com la medicina o l'enginyeria. </li> <li>1980s: S'inicia un segon per\u00edode d'inter\u00e8s per la IA, impulsat per l'augment de la pot\u00e8ncia de c\u00e0lcul i el desenvolupament de noves t\u00e8cniques d'aprenentatge autom\u00e0tic. Se torna a investigar en xarxes neuronals hi ha avan\u00e7os, per\u00f2 els models s\u00f3n molt complexos i necessiten supervisi\u00f3 constant i ajustos manuals. Segon hivern de la IA.</li> <li>1990s i 2000s: IA moderna, basada en probabilitat i estad\u00edstica, que permet arribar a conclusions futures a partir de dades passades. Models basats en dades, m\u00e9s flexibles que els models simb\u00f2lics.</li> <li>1997: Hui sembla una an\u00e8cdota, per\u00f2 l'ordinador Deep Blue d'IBM guanya al campi\u00f3 mundial d'escacs Garry Kasparov, marcant un moment hist\u00f2ric en la IA.</li> <li>2010s: la gran quantitat de dades i les t\u00e8cniques de tractament (Big Data), aix\u00ed com la computaci\u00f3 al n\u00favol (menys necessitat de recursos locals), permeten l'\u00fas de models d'aprenentatge profund (Deep Learning) i xarxes neuronals convolucionals, que han revolucionat la IA en \u00e0rees com la visi\u00f3 per computador i el processament del llenguatge natural.</li> <li>Algunes fites dels darrers anys:</li> <li>2011: IBM Watson guanya el concurs de preguntes i respostes Jeopardy!, demostrant la capacitat de processar i entendre el llenguatge natural.</li> <li>2012: AlexNet guanya la competici\u00f3 ImageNet, demostrant l'efic\u00e0cia de les xarxes neuronals profundes en el reconeixement d'imatges.</li> <li>el v\u00eddeo dels 500 milions de d\u00f2lars de DeepMind: Deep-Q aprenent a jugar el joc Atari Breakout. enlla\u00e7 per veure el video</li> <li>2015: Google allibera el seu sistema d'IA, TensorFlow, que es converteix en un dels marcs m\u00e9s utilitzats per a l'aprenentatge autom\u00e0tic i les xarxes neuronals.</li> <li>2016: AlphaGo, desenvolupat per DeepMind, guanya al campi\u00f3 mundial de Go, un joc extremadament complex.</li> <li>2020: GPT-3, un model de llenguatge natural desenvolupat per OpenAI, demostra una capacitat sorprenent per a generar text coherent i realista que ha anat millorant molt des d'aleshores. Utilitza 175 mil milions de par\u00e0metres i \u00e9s capa\u00e7 de realitzar una \u00e0mplia gamma de tasques de processament del llenguatge natural, com traducci\u00f3, resum, generaci\u00f3 de text i resposta a preguntes. OpenAI no ha donat informaci\u00f3 de quants par\u00e0metres t\u00e9 el model GPT-4, tot i que certes fonts parlen de 250 mil millions.</li> <li>Capacitat de generar imatges, v\u00eddeos i \u00e0udio de manera realista, com DALL-E, Stable Diffusion, Midjourney... Imatges de rostres humans inexistents.</li> <li>Deep Learning*: una branca de l'aprenentatge autom\u00e0tic del que analitzarem m\u00e9s detalladament en el m\u00f2dul de Sistemes d'Aprenentatge Autom\u00e0tic**, on estudiarem tamb\u00e9 els diferents tipus d'aprenentatge autom\u00e0tic (supervisat, no supervisat, per refor\u00e7).</li> </ul>"},{"location":"u01/#tipus-dintelligencia-artificial","title":"Tipus d'intel\u00b7lig\u00e8ncia artificial","text":"<p>La intel\u00b7lig\u00e8ncia artificial es pot classificar en diferents tipus segons el seu enfocament i les seues capacitats. En este apartat, veurem els principals tipus d'IA, des de la IA feble fins a la IA forta, i les seues caracter\u00edstiques distintives.</p>"},{"location":"u01/#ia-feble","title":"IA feble","text":"<p>La IA feble, tamb\u00e9 coneguda com a IA estreta (narrow AI), es refereix a sistemes d'intel\u00b7lig\u00e8ncia artificial dissenyats per a realitzar tasques espec\u00edfiques i limitades. Estos sistemes no tenen consci\u00e8ncia ni comprensi\u00f3 general del m\u00f3n, sin\u00f3 que estan enfocats en resoldre problemes concrets. S\u00f3n reactius, la qual cosa vol dir que no tenen iniciativa sino que reaccionen a certes ordres o accions. No \"aprenen\" com un \u00e9sser hum\u00e0: \"entrenen\" amb dades o per amb moltes proves/errors.</p> <p>Alguns exemples d'IA feble inclouen:</p> <ul> <li>Assistents virtuals com Siri o Alexa, que poden respondre preguntes i realitzar tasques senzilles.</li> <li>Algoritmes de recomanaci\u00f3 en plataformes com Netflix o Amazon, que suggereixen contingut basat en les prefer\u00e8ncies de l'usuari.</li> <li>Sistemes de reconeixement de veu i imatge, que poden identificar patrons en dades espec\u00edfiques.   </li> </ul> <p>Com podeu veure, la IA feble \u00e9s la que s'ha estat desenvolupant i utilitzant en els darrers anys, i \u00e9s la que trobem en la majoria de les aplicacions d'IA actuals. La seua limitaci\u00f3 \u00e9s que no pot generalitzar coneixements ni aprendre de manera aut\u00f2noma fora del seu \u00e0mbit espec\u00edfic. Per tal de poder superar els \"hiverns de la IA\", se va apostar per este enfocament m\u00e9s pragm\u00e0tic i realista.</p>"},{"location":"u01/#ia-forta","title":"IA forta","text":"<p>La IA forta, tamb\u00e9 coneguda com a IA general (general AI), es refereix a sistemes d'intel\u00b7lig\u00e8ncia artificial que tenen la capacitat de comprendre, aprendre i aplicar coneixements en una \u00e0mplia gamma de tasques, similar a la intel\u00b7lig\u00e8ncia humana. Estos sistemes podrien raonar, planificar, resoldre problemes i adaptar-se a noves situacions sense necessitat d'intervenci\u00f3 humana constant. En teoria serien proactives, \u00e9s a dir, no necessitarian una ordre o un \u00e9sser hum\u00e0 demanant-li una tasca. Tamb\u00e9 en teoria (de moment), serien capaces de raonar com un \u00e9sser hum\u00e0.</p> <p>La IA forta encara \u00e9s un objectiu a llarg termini en la investigaci\u00f3 d'IA, i no s'ha aconseguit completament. No obstant aix\u00f2, els avan\u00e7os en \u00e0rees com l'aprenentatge autom\u00e0tic, les xarxes neuronals i el processament del llenguatge natural estan apropant-nos cada vegada m\u00e9s a este objectiu.</p> <p></p>"},{"location":"u01/#debats","title":"Debats:","text":"<ul> <li>IA feble vs IA forta</li> <li>chatGPT, DeepSeek, NotebookLM, Gemini... S\u00f3n IAs febles o fortes?</li> </ul>"},{"location":"u01/#ia-simbolica-convencional-vs-ia-basada-en-dades-computacional","title":"IA simb\u00f2lica (convencional) vs IA basada en dades (computacional)","text":"<p>La IA simb\u00f2lica (o convencional) es basa en la representaci\u00f3 del coneixement mitjan\u00e7ant s\u00edmbols i regles l\u00f2giques. Este enfocament utilitza sistemes basats en regles, l\u00f2gica i raonament per a resoldre problemes i prendre decisions. La IA simb\u00f2lica ha estat utilitzada en sistemes experts i en la resoluci\u00f3 de problemes matem\u00e0tics. \u00c9s poc flexible i complicada d'escalar. En els anys 80 utilitz\u00e0vem llenguatges com Prolog o Lisp per a programar este tipus d'IA. La IA simb\u00f2lica (de vegades anomenada IA cl\u00e0ssica), per tant, requereix un coneixement previ i expl\u00edcit per a funcionar, i es basa en la l\u00f2gica i les regles per a processar la informaci\u00f3.</p> <p>Exemples d'IA simb\u00f2lica inclouen:</p> <ul> <li>Sistemes experts que utilitzen regles per a resoldre problemes en \u00e0rees espec\u00edfiques, com la medicina o l'enginyeria.</li> <li>Xarxes bayesianes (grafos) que utilitzen probabilitats per a inferir conclusions a partir de dades (plou --&gt; la terra est\u00e0 mullada).</li> <li>Sistemes de raonament l\u00f2gic que poden deduir conclusions a partir de premisses i regles.</li> <li>Sistemes de processament del llenguatge natural que utilitzen gram\u00e0tiques i regles per a analitzar i generar text.</li> </ul> <p>Esta seria la part que veuriem en este m\u00f2dul de Models d'Intelig\u00e8ncia Artificial. </p> <p>La IA basada en dades (o computacional), en canvi, es fonamenta en l'aprenentatge autom\u00e0tic i l'an\u00e0lisi de grans volums de dades per a identificar patrons i fer prediccions. No treballa amb regles sino amb exemples i generalitzacions. Este enfocament ha guanyat popularitat en els darrers anys gr\u00e0cies a l'augment de la pot\u00e8ncia de c\u00e0lcul i la disponibilitat de dades massives. Ac\u00ed entraria tant el Machine Learning com el Deep Learning (ja veurem les difer\u00e8ncies).</p> <p>Exemples d'IA basada en dades inclouen:</p> <ul> <li>Algoritmes de classificaci\u00f3 i regressi\u00f3 que utilitzen dades hist\u00f2riques per a fer prediccions sobre esdeveniments futurs.</li> <li>Xarxes neuronals que aprenen a recon\u00e8ixer patrons en imatges, veu o text.</li> <li>Models de processament del llenguatge natural que utilitzen t\u00e8cniques d'aprenentatge autom\u00e0tic per a analitzar i generar text de manera coherent. Per exemple, per mantindre una conversa o per fer an\u00e0lisi de sentiments (determinar si un text expressa una opini\u00f3 positiva, negativa o neutra).</li> <li>Sistemes de recomanaci\u00f3 que utilitzen dades d'usuari per a suggerir contingut personalitzat, com pel\u00b7l\u00edcules, m\u00fasica o productes.</li> </ul> <p>La part de la IA basada en dades i en l'aprenentatge autom\u00e0tic \u00e9s la que veurem en el m\u00f2dul de Sistemes d'Aprenentatge Autom\u00e0tic.</p> <p>Podr\u00edem dir que la IA simb\u00f2lica se programa a la manera (m\u00e9s o menys) tradicional, mentre que la IA basada en dades s'entrena a partir de dades. Aix\u00f2 implica que la IA simb\u00f2lica requereix un coneixement previ i expl\u00edcit per a funcionar, mentre que la IA basada en dades pot aprendre de manera aut\u00f2noma a partir de les dades que se li proporcionen.</p> <p>Tamb\u00e9 se parla d'una IA h\u00edbrida, que combina xarxes neuronals (de la IA computacional) amb regles i representacions simb\u00f2liques (de la IA simb\u00f2lica o convencional). En eixa classificaci\u00f3 podrien entrar eines com chatGPT.</p> <p></p>"},{"location":"u01/#ia-generativa","title":"IA Generativa","text":"<p>La IA generativa \u00e9s un tipus d'intel\u00b7lig\u00e8ncia artificial que es centra en la creaci\u00f3 de contingut nou i original, com imatges, m\u00fasica, text o fins i tot v\u00eddeos. A difer\u00e8ncia d'altres tipus d'IA que es basen en l'an\u00e0lisi i la classificaci\u00f3 de dades existents, la IA generativa utilitza models avan\u00e7ats per a generar contingut que no existia pr\u00e8viament.</p> <p>Podr\u00edem classificar la IA generativa dins de la IA basada en dades, ja que utilitza grans quantitats de dades per a entrenar els seus models. No obstant aix\u00f2, la seua capacitat per a crear contingut nou i original la fa destacar com un tipus d'IA amb caracter\u00edstiques pr\u00f2pies.</p>"},{"location":"u01/#camps-daplicacio-de-la-ia","title":"Camps d'aplicaci\u00f3 de la IA","text":"<p>La intel\u00b7lig\u00e8ncia artificial t\u00e9 una \u00e0mplia gamma d'aplicacions en diversos camps. Algunes de les \u00e0rees m\u00e9s destacades on s'est\u00e0 utilitzant la IA s\u00f3n:</p> <ul> <li>Processament del llenguatge natural (NLP): La IA s'utilitza per a analitzar, comprendre i generar text en llenguatge hum\u00e0. Aix\u00f2 inclou traducci\u00f3 autom\u00e0tica, assistents virtuals, an\u00e0lisi de sentiments i generaci\u00f3 de text.</li> <li>Visi\u00f3 per computador: La IA s'aplica en el reconeixement d'imatges i v\u00eddeos, permetent la detecci\u00f3 d'objectes, el reconeixement facial i la classificaci\u00f3 d'imatges. Aix\u00f2 \u00e9s \u00fatil en \u00e0rees com la seguretat, la salut i l'automoci\u00f3.</li> <li>Rob\u00f2tica: La IA s'utilitza per a controlar robots i sistemes aut\u00f2noms, permetent-los realitzar tasques complexes com la navegaci\u00f3, la manipulaci\u00f3 d'objectes i la interacci\u00f3 amb humans. Aix\u00f2 inclou robots de neteja, drones i vehicles aut\u00f2noms.</li> <li>Sistemes de recomanaci\u00f3: La IA s'aplica en plataformes com Netflix, Amazon i Spotify per a suggerir contingut personalitzat als usuaris, basant-se en les seues prefer\u00e8ncies i comportaments anteriors.</li> <li>Models predictius: La IA s'utilitza per a analitzar dades hist\u00f2riques i fer prediccions sobre esdeveniments futurs. Aix\u00f2 \u00e9s \u00fatil en \u00e0rees com la salut, les finances, el clima i la log\u00edstica, entre altres.</li> <li>Models generatius: La IA s'aplica en la creaci\u00f3 de contingut nou, com imatges, m\u00fasica i text. Aix\u00f2 inclou models com DALL-E, que generen imatges a partir de descripcions textuals, i GPT-3, que pot generar text coherent i realista (aix\u00f2 formaria part del camp del processament del llenguatge natural).</li> <li>Agents intel\u00b7ligents: La IA s'utilitza per a crear agents aut\u00f2noms que poden interactuar amb el seu entorn, prendre decisions i aprendre de l'experi\u00e8ncia. Aix\u00f2 inclou sistemes de navegaci\u00f3, assistents virtuals i robots aut\u00f2noms. Ara parlarem d'ells.</li> </ul>"},{"location":"u01/#agents-intelligents","title":"Agents intel\u00b7ligents","text":"<p>Els agents intel\u00b7ligents s\u00f3n entitats capaces de percebre el seu entorn a trav\u00e9s de sensors i actuar-hi mitjan\u00e7ant efectors per assolir objectius espec\u00edfics. Se caracteritzen per tindre:</p> <ul> <li>autonomia</li> <li>reactivitat</li> <li>proactivitat (iniciativa)</li> <li>capacitat d'interactuar</li> <li>mem\u00f2ria i planificaci\u00f3 (context intern i extern)</li> </ul> <p>Components d'un agent intel\u00b7ligent:</p> <ul> <li>Sensors(S): Els sensors s\u00f3n dispositius que permeten a l'agent percebre informaci\u00f3 sobre el seu entorn. Poden incloure c\u00e0meres, micr\u00f2fons, sensors de temperatura, GPS, entre d'altres. La informaci\u00f3 que recopilen els sensors s'utilitza per representar l'estat actual de l'entorn.</li> <li>Actuadors(A): Els actuadors s\u00f3n els mitjans mitjan\u00e7ant els quals l'agent interactua amb el seu entorn. Poden ser rodes en un robot, motors en un bra\u00e7 rob\u00f2tic o simplement sortides de dades en un sistema de programari. Els actuadors permeten que l'agent faci accions per assolir els objectius.</li> <li>Funci\u00f3 (F): La funci\u00f3 de l'agent representa el comportament de l'agent segons les percepcions que rep. Pren com a entrada l'estat actual de l'entorn i torna una acci\u00f3 que l'agent ha d'executar. Aquesta funci\u00f3 pot ser simple o complexa, depenent de la complexitat de la tasca que lagent ha de realitzar.</li> <li>Arquitectura (A): L'arquitectura de l'agent fa refer\u00e8ncia a com s'organitza l'agent en termes dels seus components i com interactuen entre si. Hi pot haver diferents arquitectures segons la complexitat de la tasca i els requisits de rendiment.</li> </ul> <p>Exemples comuns podrien ser:</p> <ul> <li>un sistema de navegaci\u00f3 o conducci\u00f3 autom\u00e0tica</li> <li>un robot de neteja autom\u00e0tic</li> <li>un assistent virtual com Siri o Alexa</li> <li>un sistema de recomanaci\u00f3 de contingut en l\u00ednia</li> </ul>"},{"location":"u01/#protocols-acp-i-mcp","title":"Protocols ACP i MCP","text":"<p>Els protocols de comunicaci\u00f3 entre agents (ACP, Agent Communication Protocols) s\u00f3n conjunts de regles i convencions que permeten als agents intel\u00b7ligents intercanviar informaci\u00f3 i coordinar les seues accions en un entorn compartit. Aquests protocols s\u00f3n essencials per a la col\u00b7laboraci\u00f3 i la cooperaci\u00f3 entre agents en sistemes multi-agent.</p> <p>D'altra banda, els protocols (MCP, Model Context Protocols) s\u00f3n dissenyats per gestionar i compartir informaci\u00f3 sobre el context en qu\u00e8 operen els agents. Aquests protocols permeten als agents accedir a recursos externs, i per tant adaptar el seu comportament segons les condicions canviants de l'entorn i les necessitats dels altres agents.</p>"},{"location":"u01/#implicacions-etiques-i-socials","title":"Implicacions \u00e8tiques i socials","text":"<ul> <li>Protecci\u00f3 de dades i privacitat: Com es gestionen les dades personals i sensibles en els sistemes d'IA?</li> <li>Informaci\u00f3 molt personal i consentiment: Com es garanteix que els usuaris donen el seu consentiment informat per a l'\u00fas de les seues dades?</li> <li>Discriminaci\u00f3 i biaixos: Com es poden evitar els biaixos en els models d'IA que poden portar a la discriminaci\u00f3 de certs grups?</li> <li>Seguretat i responsabilitat: Qui \u00e9s responsable en cas d'errors o danys causats per sistemes d'IA?</li> <li>Autonomia i control: Com es pot garantir que els sistemes d'IA no prenguin decisions que afecten la vida de les persones sense supervisi\u00f3 humana?</li> <li>Impacte en la societat: Com afectar\u00e0 la IA a les relacions socials, la cultura i la pol\u00edtica?</li> <li>Transpar\u00e8ncia i explicabilitat: Com es poden explicar les decisions preses per sistemes d'IA?</li> <li>Impacte en l'ocupaci\u00f3: Com afectar\u00e0 la IA al mercat laboral i a les professions tradicionals?</li> </ul>"},{"location":"u02/","title":"Models d'IA. M\u00e8todes de representaci\u00f3.","text":"<p>En esta unitat anem a treballar amb el concepte de model en el camp de la intel\u00b7lig\u00e8ncia artificial (IA). Veurem la seua definici\u00f3, quins tipus de models existeixen, i quines aplicacions poden tindre en la pr\u00e0ctica. </p> <p>Tamb\u00e9 veurem quins s\u00f3n els requeriments b\u00e0sics d'un sistema de resoluci\u00f3 de problemes i dels diferents models d'IA. Per exemple, automatitzaci\u00f3 de tasques, sistemes de raonament imprec\u00eds, sistemes basats en regles, i algorismes de cerca i optimitzaci\u00f3.</p>"},{"location":"u02/#que-es-un-model","title":"Qu\u00e8 \u00e9s un model?","text":"<p>Un model \u00e9s una representaci\u00f3 simplificada d'un sistema o fenomen que permet analitzar-lo, entendre'l i fer prediccions sobre el seu comportament. En el context de la intel\u00b7lig\u00e8ncia artificial, un model \u00e9s una estructura matem\u00e0tica o computacional que captura les relacions entre les dades d'entrada i les sortides esperades. Un model s'entrenar\u00e0 amb dades per aprendre a fer prediccions o a prendre decisions basades en aquesta informaci\u00f3.</p> <p></p>"},{"location":"u02/#models-i-algorismes","title":"Models i algorismes.","text":"<p>Els models i els algorismes s\u00f3n conceptes relacionats per\u00f2 diferents en el context de la intel\u00b7lig\u00e8ncia artificial. Un algorisme \u00e9s un conjunt de regles o passos que es segueixen per resoldre un problema o realitzar una tasca espec\u00edfica, mentre que un model \u00e9s la representaci\u00f3 del coneixement adquirit a partir de les dades. Per a que un model funcione, necessita ser entrenat amb un o varis algorismes, que s\u00f3n els que permeten ajustar els par\u00e0metres del model per tal que aquest puga fer prediccions o prendre decisions. Els models poden ser entrenats o no entrenats, depenent del tipus d'aprenentatge que s'utilitze.</p> <p>Els models entrenats serien aquells que han passat per un proc\u00e9s d'aprenentatge autom\u00e0tic, on s'ajusten els seus par\u00e0metres a partir de dades d'entrenament. Aix\u00f2 permet que el model aprenga a generalitzar i a fer prediccions sobre dades noves. Un exemple seria un model de classificaci\u00f3 que ha estat entrenat amb un conjunt de dades etiquetades per identificar diferents categories, tipus d'animals, etc. Estariem parlant de models de Machine Learning o Deep Learning, dos tipus d'aprenentatge autom\u00e0tic que se corresponen amb IA basada en dades.</p> <p>Els models no entrenats, en canvi, s\u00f3n aquells que no han passat per un proc\u00e9s d'aprenentatge autom\u00e0tic i, per tant, no tenen par\u00e0metres ajustats. Aquests models poden ser utilitzats per a tasques espec\u00edfiques on no es requereix aprenentatge previ, com ara models basats en regles o sistemes de raonament simb\u00f2lic. Estariem parlant, com hem vist en la introducci\u00f3, de IA simb\u00f2lica o basada en regles. Un sistema expert \u00e9s un exemple de model no entrenat, ja que es basa en regles i coneixements predefinits per resoldre problemes espec\u00edfics en un domini particular. En canvi, un model de xarxa neuronal seria un exemple de model entrenat, ja que requereix un proc\u00e9s d'entrenament per ajustar els seus pesos i connexions a partir de dades d'entrenament. Este tipo de model \u00e9s determinista, \u00e9s a dir, que per a una entrada donada sempre produir\u00e0 la mateixa sortida. </p>"},{"location":"u02/#mes-tipus-de-models","title":"M\u00e9s tipus de models.","text":"<p>Podem fer altres classificacions m\u00e9s especialitzades dels models d'IA. Per exemple, podem diferenciar entre models d'IA basats en regles i models d'aprenentatge autom\u00e0tic, com hem vist, per\u00f2 tamb\u00e9 podem parlar de models de raonament imprec\u00eds, models generatius, models discriminatius, models de cerca i optimitzaci\u00f3, models de processament del llenguatge, etc. Cada tipus de model t\u00e9 les seues pr\u00f2pies caracter\u00edstiques i aplicacions. </p> <p>Dins dels models d'aprenentatge autom\u00e0tic, podem distingir entre:</p> <ul> <li>Models supervisats: S\u00f3n entrenats amb dades etiquetades, on cada entrada t\u00e9 una sortida coneguda. L'objectiu \u00e9s aprendre una funci\u00f3 que siga capa\u00e7 de predir la sortida per a noves entrades. Dins dels models supervisats, podem trobar models de classificaci\u00f3 (per exemple, per identificar si un correu electr\u00f2nic \u00e9s spam o no) i Models de regressi\u00f3 (per exemple, per predir el preu d'una casa en funci\u00f3 de les seues caracter\u00edstiques).</li> <li>Models no supervisats: S\u00f3n entrenats amb dades no etiquetades, on l'objectiu \u00e9s descobrir patrons o estructures ocultes en les dades. Per exemple, els models de Clustering (agrupament) poden identificar grups de dades similars sense necessitat d'etiquetes pr\u00e8vies. Tamb\u00e9 podem utilitzar este tipus de models en els sistemes de recomanaci\u00f3, on es busca agrupar usuaris o productes en funci\u00f3 de les seues prefer\u00e8ncies.</li> <li>Models de refor\u00e7: S\u00f3n entrenats utilitzant un sistema de recompenses i c\u00e0stigs, on l'agent apr\u00e8n a prendre decisions per maximitzar la seua recompensa a llarg termini.</li> </ul> <p>Cada vegada s'utilitzen m\u00e9s els sistemes h\u00edbrids, que combinen diferents tipus de models per aprofitar les seues fortaleses i minimitzar les seues debilitats. Per exemple, un sistema pot utilitzar un model basat en regles per a la presa de decisions inicials i un model d'aprenentatge autom\u00e0tic per millorar la precisi\u00f3 de les prediccions a mesura que es disposa de m\u00e9s dades.</p> <p>Tots els tipus de models que tinguen a veure amb l'aprenentatge autom\u00e0tic s'estudiaran en m\u00e9s detall al m\u00f2dul de Sistemes d'Aprenentatge Autom\u00e0tic del Curs d'Especialitzaci\u00f3.</p>"},{"location":"u02/#aplicacions","title":"Aplicacions.","text":"<p>Els models d'IA tenen una \u00e0mplia gamma d'aplicacions en diversos camps. Algunes de les aplicacions m\u00e9s comunes inclouen:</p> <ul> <li>Reconeixement de veu: Els sistemes de reconeixement de veu converteixen la parla en text i poden automatitzar la transcripci\u00f3 de documents o ordres de veu en dispositius. Per exemple, aplicacions de reconeixement de veu com Google Speech-to-Text o Microsoft Azure Speech Service permeten convertir enregistraments de veu en text escrit de manera automatitzada.</li> <li>Reconeixement i processament d'imatges: Els models d'IA poden identificar objectes, persones o escenes en imatges i v\u00eddeos, utilitzats en aplicacions de seguretat, automoci\u00f3 i salut. Per exemple, els sistemes de reconeixement facial poden identificar persones en fotografies o v\u00eddeos, millorant la seguretat en espais p\u00fablics o facilitant l'acc\u00e9s a dispositius. Altres aplicacions de l'an\u00e0lisi d'imatges podria ser la detecci\u00f3 de tumors en radiografies o en la identificaci\u00f3 de productes en imatges de comer\u00e7 electr\u00f2nic. Per exemple, els sistemes de visi\u00f3 per computador poden analitzar imatges m\u00e8diques per detectar anomalies o lesions, millorant aix\u00ed el diagn\u00f2stic i el tractament dels pacients.</li> <li>Sistemes de recomanaci\u00f3: Els models d'IA poden analitzar les prefer\u00e8ncies dels usuaris i suggerir productes, pel\u00b7l\u00edcules, m\u00fasica o altres continguts personalitzats. Per exemple, plataformes com Netflix o Spotify utilitzen sistemes de recomanaci\u00f3 per oferir contingut adaptat als gustos dels seus usuaris.</li> <li>Detecci\u00f3 de patrons i anomalies: Els models d'IA poden identificar patrons en grans volums de dades i detectar anomalies que podrien indicar problemes o oportunitats. Per exemple, en el sector financer, els models d'IA poden analitzar transaccions per identificar patrons de comportament normal i detectar desviacions que podrien indicar frau o errors.</li> <li>Assistents virtuals: Els assistents virtuals com Siri, Alexa o Google Assistant utilitzen models d'IA per entendre i respondre a les consultes dels usuaris, automatitzant tasques com la programaci\u00f3 d'esdeveniments o la recerca d'informaci\u00f3. Per exemple, un assistent virtual pot ajudar a gestionar el calendari personal, enviar missatges o controlar dispositius intel\u00b7ligents a casa.</li> <li>Processament del llenguatge natural (NLP): Els models d'IA poden analitzar i generar text en llenguatge natural, utilitzats en traducci\u00f3 autom\u00e0tica, an\u00e0lisi de sentiments i generaci\u00f3 de contingut. Per exemple, els sistemes de traducci\u00f3 autom\u00e0tica com Google Translate utilitzen models d'IA per traduir textos entre diferents idiomes de manera precisa i r\u00e0pida.</li> <li>Rob\u00f2tica i automatitzaci\u00f3: Els models d'IA poden controlar robots i sistemes automatitzats per realitzar tasques complexes, com ara en la fabricaci\u00f3, la log\u00edstica o l'agricultura. Per exemple, els robots industrials equipats amb models d'IA poden realitzar tasques de muntatge, soldadura o embalatge de manera eficient i precisa. Els vehicles aut\u00f2noms tamb\u00e9 utilitzen models d'IA per percebre l'entorn, prendre decisions i navegar de manera segura.</li> </ul> <p></p> <p>Un LLM (Large Language Model) \u00e9s un tipus de model d'IA dissenyat per processar i generar text en llenguatge natural. Aquests models utilitzen t\u00e8cniques d'aprenentatge autom\u00e0tic per aprendre les estructures i patrons del llenguatge a partir de grans volums de dades textuals. Els LLM s\u00f3n capa\u00e7os de realitzar tasques com la traducci\u00f3 autom\u00e0tica, la generaci\u00f3 de text coherent, la resposta a preguntes i l'an\u00e0lisi de sentiments.</p>"},{"location":"u02/#representacio-del-coneixement","title":"Representaci\u00f3 del coneixement.","text":"<p>La representaci\u00f3 del coneixement \u00e9s un aspecte fonamental en la intel\u00b7lig\u00e8ncia artificial, ja que permet als sistemes d'IA emmagatzemar, organitzar, entendre i utilitzar la informaci\u00f3 de manera eficient.</p>"},{"location":"u02/#jerarquia-del-coneixement","title":"Jerarquia del coneixement.","text":"<p>Per entendre com representar el coneixement, \u00e9s interessant entendre primer qu\u00e8 \u00e9s coneixement en realitat. Hi ha un esquema anomenat Pir\u00e0mide del coneixement o tamb\u00e9 Jerarqu\u00eda DIKW que ens ajudar\u00e0 a entendre com es relacionen els diferents nivells de coneixement. Esta jerarquia es pot dividir en quatre nivells:</p> <ul> <li>Data (dades): S\u00f3n fets o valors sense context ni significat. Per exemple, un n\u00famero, una paraula o una mesura. Les dades s\u00f3n la base de la informaci\u00f3, per\u00f2 per si soles no tenen cap significat. Per exemple, imaginem un 38. Qu\u00e8 significa? No ho sabem, perqu\u00e8 no tenim un context. Pot ser la temperatura d'un dia, l'edat d'una persona, o el nombre de persones en una sala. Sense m\u00e9s informaci\u00f3, no podem interpretar el seu significat.</li> <li>Information (Informaci\u00f3): \u00c9s el resultat de processar les dades i donar-los un context. Per exemple, si diem \"La temperatura \u00e9s de 38 graus\", estem proporcionant informaci\u00f3 que t\u00e9 un significat clar. La informaci\u00f3 \u00e9s \u00fatil perqu\u00e8 ens permet entendre millor les dades i prendre decisions basades en elles. Ara eixe 38 ja t\u00e9 un significat, podem interpretar-lo i utilitzar-lo en el nostre sistema de representaci\u00f3 de coneixement i presa de decisions.</li> <li>Knowledge (Coneixement): \u00c9s la comprensi\u00f3 i l'aplicaci\u00f3 de la informaci\u00f3 integrada dins d'un context m\u00e9s ampli i fent \u00fas de regles o coneiximents previs. Per exemple, en el nostre cas, sabem que una temperatura de 38 graus pot ser un s\u00edmptoma de febre, i que aix\u00f2 pot indicar que una persona est\u00e0 malalta. El coneixement implica la capacitat d'aplicar la informaci\u00f3 a situacions espec\u00edfiques i de prendre decisions informades.</li> <li>Wisdom (Saviesa): \u00c9s la capacitat de prendre decisions i actuar de manera \u00e8tica i responsable basant-se en el coneixement adquirit. La saviesa implica no nom\u00e9s comprendre la informaci\u00f3 i el coneixement, sin\u00f3 tamb\u00e9 saber com aplicar-los de manera adequada en situacions complexes. De vegades se parla de la saviesa com d'un metaconeixement, \u00e9s a dir, saber qu\u00e8 fer amb eixe coneixement que acabem d'adquirir. Per exemple, si sabem que una persona t\u00e9 38\u00ba de temperatura corporal, i tambi\u00e9n sabem que aix\u00f2 \u00e9s febre, podem decidir recomanar-li que vagi al metge, que es quede a casa per descansar o fins i tot que prenga cert medicament.</li> </ul> <p></p>"},{"location":"u02/#representacio","title":"Representaci\u00f3.","text":"<p>La representaci\u00f3 del coneixement \u00e9s un dels problemes fonamentals en el m\u00f3n de l'intel\u00b7lig\u00e8ncia artificial. Podem definir representaci\u00f3 del coneixement com el proc\u00e9s de codificar la informaci\u00f3 i les relacions entre diferents conceptes d'una manera que els sistemes d'IA puguen entendre i utilitzar. En el proc\u00e9s ens trobarem molts obstacles, at\u00e9s que la quantitat d'informaci\u00f3 i coneixement que necessitem gestionar \u00e9s enorme (tot el coneixement del m\u00f3n?), i que la seua representaci\u00f3 moltes vegades \u00e9s verbal o esquem\u00e0tica i cal traduir-la d'alguna manera que siga interpretable pels sistemes d'IA. </p> <p>Hi ha diverses t\u00e8cniques i estructures per a representar el coneixement. Algunes de les m\u00e9s destacades s\u00f3n:</p> <ul> <li>Regles de producci\u00f3: S\u00f3n regles que defineixen relacions entre condicions i accions. Per exemple, Si plou, agafa el paraig\u00fces. Aquestes regles es poden utilitzar en sistemes basats en regles per a la presa de decisions.</li> <li>Ontologies: S\u00f3n estructures que representen coneixements sobre un domini espec\u00edfic, incloent classes, atributs i relacions entre ells. Les ontologies permeten una representaci\u00f3 m\u00e9s rica i estructurada del coneixement, facilitant la interoperabilitat entre diferents sistemes. Per exemple, una ontologia sobre animals podria incloure classes com \"Mam\u00edfers\", \"Aus\" i \"R\u00e8ptils\", amb atributs com \"nom\", \"color\" i relacions com un gat \u00e9s un tipus de mam\u00edfer.</li> <li>Grafos de coneixement: S\u00f3n representacions que utilitzen nodes i arestes per modelar relacions entre entitats. Els grafos de coneixement s\u00f3n \u00fatils per representar informaci\u00f3 complexa i interrelacionada, com ara les relacions entre persones, llocs i esdeveniments. Hi pot haver una relaci\u00f3 jer\u00e0rquica entre les entitats, com ara un gat \u00e9s un tipus d'animal, o altres relacions no necess\u00e0riament jer\u00e0rquiques, com un autor ha escrit un llibre.</li> <li> <p>L\u00f2giques formals: S\u00f3n sistemes matem\u00e0tics que permeten representar coneixements i raonar sobre ells. Hi ha diferents tipus de l\u00f2giques formals, com ara la l\u00f2gica proposicional, la l\u00f2gica de primer ordre i la l\u00f2gica difusa. Aquestes l\u00f2giques s\u00f3n \u00fatils per a la representaci\u00f3 del coneixement en sistemes experts i en la resoluci\u00f3 de problemes complexos.</p> <ul> <li>L\u00f2gica de primer ordre o de predicats: \u00c9s un sistema formal que permet representar afirmacions i raonar sobre elles utilitzant quantificadors i predicats. La l\u00f2gica de primer ordre \u00e9s \u00fatil per a la representaci\u00f3 del coneixement en sistemes experts i en la resoluci\u00f3 de problemes complexos. Exemples: </li> <li>Tots els humans s\u00f3n mortals es pot representar com \u2200x (Hum\u00e0(x) \u2192 Mortal(x)).</li> <li>Hi ha almenys un gat que \u00e9s negre es pot representar com \u2203x (Gat(x) \u2227 Negre(x)).</li> <li>L\u00f2gica proposicional: \u00c9s un sistema formal que utilitza proposicions i operadors l\u00f2gics per representar coneixements i raonar sobre ells. La l\u00f2gica proposicional \u00e9s \u00fatil per a la representaci\u00f3 de coneixements senzills i per a la resoluci\u00f3 de problemes l\u00f2gics. Exemples:</li> <li>Si plou, llavors el terra est\u00e0 mullat es pot representar com P \u2192 Q, on P \u00e9s plou i Q \u00e9s el terra est\u00e0 mullat. La fletxa \u2192 indica una implicaci\u00f3 l\u00f2gica.</li> <li>El sol brilla o est\u00e0 n\u00favol es pot representar com P \u2228 Q, on P \u00e9s el sol brilla i Q \u00e9s est\u00e0 n\u00favol. El s\u00edmbol \u2228 indica una disjunci\u00f3 l\u00f2gica, que significa que almenys una de les dues proposicions \u00e9s certa.</li> <li>L\u00f2gica difusa: \u00c9s una extensi\u00f3 de la l\u00f2gica proposicional que permet representar incerteses i graus de veritat. La l\u00f2gica difusa \u00e9s \u00fatil per a la representaci\u00f3 del coneixement en sistemes que impliquen raonament imprec\u00eds o subjectiu, com ara en la presa de decisions en situacions amb informaci\u00f3 incompleta o amb variables cont\u00ednues. Exemples:</li> <li>La temperatura \u00e9s fresca es pot representar com un valor dif\u00fas entre 0 i 1, on 0 significa no \u00e9s fresca i 1 significa \u00e9s fresca.</li> <li>El nivell d'estr\u00e8s \u00e9s moderat es pot representar com un valor dif\u00fas que indica el grau d'estr\u00e8s en una escala de 0 a 1.</li> <li>El grau de satisfacci\u00f3 del client \u00e9s alt es pot representar com un valor dif\u00fas que indica el nivell de satisfacci\u00f3 en una escala de 0 a 1.</li> </ul> <p></p> </li> </ul>"},{"location":"u02/#representacio-de-problemes-i-sistemes-de-resolucio-requeriments-basics","title":"Representaci\u00f3 de problemes i sistemes de resoluci\u00f3. Requeriments b\u00e0sics.","text":"<p>De la mateixa forma que hem de ser capa\u00e7os de representar el coneixement per a poder utilitzar-lo, tamb\u00e9 hem de ser capa\u00e7os de representar els problemes que volem resoldre. La representaci\u00f3 del problema \u00e9s fonamental per a la seua resoluci\u00f3 efectiva. En general hem de poder definir un punt de partida, un lloc al que volem arribar, quines s\u00f3n les possibles accions per aconseguir-ho, i quines s\u00f3n les restriccions o condicions que hem de tindre en compte. Aix\u00f2 ens permetr\u00e0 dissenyar un sistema de resoluci\u00f3 de problemes que siga capa\u00e7 d'analitzar el problema i proposar solucions.</p> <p>Els requeriments b\u00e0sics per a un sistema de resoluci\u00f3 de problemes inclouen:</p> <ul> <li>Definici\u00f3 clara del problema: \u00c9s fonamental entendre quin \u00e9s el problema que es vol resoldre, incloent els objectius i les restriccions.</li> <li>Modelitzaci\u00f3 del problema: Representar el problema de manera que es puga analitzar i resoldre. Aix\u00f2 pot incloure la identificaci\u00f3 de les variables, les relacions entre elles i les possibles solucions. Tamb\u00e9 tot tipus de condicions o restriccions que necesitem tindre en compte.</li> <li>Estrat\u00e8gies de resoluci\u00f3: El sistema ha de poder raonar sobre la informaci\u00f3 disponible i prendre decisions informades per apropar-se a una soluci\u00f3. Necessitem per tant m\u00e8todes o algorismes que permeten explorar les possibles solucions al problema. Aix\u00f2 pot incloure diferents tipus de l\u00f2gica, t\u00e8cniques de cerca, optimitzaci\u00f3, o heur\u00edstiques.</li> <li>Adaptabilitat: El sistema ha de ser capa\u00e7 d'aprendre i millorar el seu rendiment a mesura que es resolen m\u00e9s problemes i s'obtenen m\u00e9s dades, encara que no \u00e9s aix\u00ed en tots els casos. Aix\u00f2 \u00e9s especialment important en sistemes d'aprenentatge autom\u00e0tic, on el model pot millorar la seua precisi\u00f3 amb el temps a mesura que s'entrena amb m\u00e9s dades.</li> <li>Efici\u00e8ncia computacional: El sistema ha de ser capa\u00e7 de resoldre el problema en un temps raonable i amb recursos computacionals adequats. Aix\u00f2 \u00e9s especialment important en problemes complexos o en situacions on es requereix una resposta r\u00e0pida. Necessitarem optimitzar els algorismes i models utilitzats per a garantir que el sistema siga eficient, tant en temps d'execuci\u00f3 com en l'\u00fas de recursos.</li> <li>Interacci\u00f3 amb l'usuari: En molts casos, \u00e9s important que el sistema puga interactuar amb els usuaris per obtenir informaci\u00f3 addicional, aclarir dubtes o proporcionar retroalimentaci\u00f3 sobre les solucions proposades.</li> <li>Avaluaci\u00f3 de solucions: Un cop s'han generat possibles solucions, cal avaluar-les per determinar quina \u00e9s la millor o m\u00e9s adequada per al problema plantejat. En algun moment del curs, en este m\u00f2dul o en el de Sistemes d'Aprenentatge Autom\u00e0tic, veurem t\u00e8cniques per avaluar models i solucions, com ara la validaci\u00f3 creuada, la matriu de confusi\u00f3, o les m\u00e8triques de rendiment. En funci\u00f3 de les m\u00e8triques utilitzades i els resultats, podrem triar la millor soluci\u00f3 o ajustar el model per millorar el seu rendiment.</li> <li>Implementaci\u00f3 de solucions: Finalment, cal implementar la soluci\u00f3 escollida i fer un seguiment dels resultats per assegurar-se que el problema s'ha resolt de manera efectiva.</li> </ul>"},{"location":"u02/#sistemes-basats-en-regles-sbr","title":"Sistemes Basats en Regles (SBR).","text":"<p>Els Sistemes Basats en Regles (SBR) s\u00f3n un tipus de sistema d'intel\u00b7lig\u00e8ncia artificial que utilitza regles expl\u00edcites per representar el coneixement, fer un raonament i prendre decisions. Aquestes regles es basen en condicions i accions, i es poden utilitzar per resoldre problemes espec\u00edfics en un domini particular. Per aix\u00f2 els SBR s\u00f3n fonaments en els sistemes experts: s\u00f3n molt efectius en situacions on es requereix raonament l\u00f2gic i on es pot expressar el coneixement en forma de regles.</p>"},{"location":"u02/#components-dun-sbr","title":"Components d'un SBR.","text":"<p>Un SBR est\u00e0 format per tres components principals:</p> <ul> <li>Base de coneixement: \u00c9s el conjunt de regles i fets que representen el coneixement sobre un domini espec\u00edfic. Les regles es poden expressar en forma de Si... aleshores... (IF...THEN...), on la part Si defineix les condicions i la part aleshores defineix les accions a realitzar si es compleixen aquestes condicions.    Per exemple, una regla podria ser: Si la temperatura \u00e9s superior a 30 graus, aleshores enc\u00e9n l'aire condicionat.</li> <li>Base de fets (mem\u00f2ria activa): \u00c9s el conjunt de fets coneguts en un moment donat. Els fets s\u00f3n afirmacions sobre l'estat del m\u00f3n que poden ser certes o falses per\u00f2 que descriuen la situaci\u00f3 actual del problema. Normalment solen tindre la forma IF...THEN. Per exemple, La temperatura actual \u00e9s de 32 graus seria un fet. La base de fets es pot actualitzar a mesura que es recullen nous fets o es canvien les condicions.</li> <li>Motor d'infer\u00e8ncia: \u00c9s el component que aplica les regles de la base de coneixement per raonar sobre els fets i prendre decisions. El motor d'infer\u00e8ncia pot utilitzar diferents t\u00e8cniques, com ara l'encadenament cap endavant (forward chaining) o l'encadenament cap enrere (backward chaining), per aplicar les regles i arribar a conclusions.<ul> <li>Encadenament cap endavant: Comen\u00e7a amb els fets coneguts i aplica les regles per inferir nous fets. \u00c9s \u00fatil quan es volen generar conclusions a partir d'un conjunt de dades inicials. Es tracta d'un raonament deductiu: revisa els antecedents i les regles, busca coincid\u00e8ncies i arriba a conclusions generals. Un exemple m\u00e9s elaborat podria ser: Si la temperatura \u00e9s superior a 30 graus i l'aire condicionat est\u00e0 apagat, aleshores enc\u00e9n l'aire condicionat. En este cas, el motor d'infer\u00e8ncia comen\u00e7aria amb els fets coneguts (temperatura i estat de l'aire condicionat) i aplicaria la regla per inferir una acci\u00f3.</li> <li>Encadenament cap enrere: Comen\u00e7a amb una hip\u00f2tesi o conclusi\u00f3 i busca els fets necessaris per demostrar-la. \u00c9s \u00fatil quan es vol comprovar si una hip\u00f2tesi \u00e9s certa o no. En este cas l'estrat\u00e8gia est\u00e0 dirigida pels objectius: partim d'una conclusi\u00f3 desitjada (objectiu) i busquem les condicions o regles que la fan possible. \u00c9s un raonament inductiu: parteix d'una conclusi\u00f3 general i busca els antecedents (regles IF...THEN on la part THEN coincideix amb l'objectiu buscat) que la poden justificar. Repetint el proc\u00e9s de forma recursiva arribem als fets de la Mem\u00f2ria Activa que ens permeten arribar a la conclusi\u00f3. Un possible exemple seria diagnosticar a una persona malalta: partim dels s\u00edmptomes observats (fets) i busquem les possibles causes (regles) que expliquen aquests s\u00edmptomes. Per exemple, si tenim el s\u00edmptoma de febre, podr\u00edem buscar regles que indiquen que la febre pot ser causada per una infecci\u00f3 o una reacci\u00f3 al\u00b7l\u00e8rgica.</li> </ul> </li> </ul> <p>Altres components que poden formar part d'un SBR s\u00f3n:</p> <ul> <li>Mecanismes d'aprenentatge: Alguns SBR poden incloure mecanismes per aprendre noves regles a partir de l'experi\u00e8ncia o de les dades, millorant aix\u00ed la seua base de coneixement amb el temps.</li> <li>Mecanismes d'explicaci\u00f3: Permeten al sistema explicar les conclusions o decisions preses, facilitant la comprensi\u00f3 dels usuaris sobre el raonament del sistema. Aix\u00f2 \u00e9s important per a la transpar\u00e8ncia i la confian\u00e7a en el sistema.</li> <li>Interf\u00edcie d'usuari: Permet als usuaris interactuar amb el sistema, introduir dades, consultar resultats i proporcionar retroalimentaci\u00f3. Una bona interf\u00edcie d'usuari \u00e9s important per facilitar l'\u00fas del sistema i la comprensi\u00f3 dels resultats obtinguts.</li> </ul> <p></p>"},{"location":"u02/#control-de-conflictes-en-el-motor-dinferencia","title":"Control de conflictes en el motor d'infer\u00e8ncia.","text":"<p>Es pot produir un conflicte en el SBR quan hi ha m\u00faltiples regles que poden ser aplicades a un conjunt de fets donats en cert moment. Per exemple, si tenim dues regles que poden ser aplicades a la mateixa situaci\u00f3, el sistema ha de decidir quina regla aplicar. Algunes estrat\u00e8gies per resoldre conflictes inclouen:</p> <ul> <li>Per prioritat: Assignar una prioritat a cada regla i aplicar la regla amb la prioritat m\u00e9s alta en cas de conflicte. Aix\u00f2 permet controlar quina regla t\u00e9 m\u00e9s pes en la presa de decisions.</li> <li>Per ampl\u00e0ria: Aplicar totes les regles que es poden aplicar en un nivell, generant m\u00faltiples conclusions i permetent que el sistema prenga decisions basades en una visi\u00f3 m\u00e9s completa de la situaci\u00f3 abans de passar al seg\u00fcent nivell. </li> <li>Per profunditat: Aplicar una branca o cam\u00ed fins arribar al final, i fer el mateix en la resta de camins.</li> <li>Per complexitat: Prioritzar les regles m\u00e9s complexes, o les m\u00e9s senzilles.</li> <li>M\u00e9s utilitzades o m\u00e9s recents: Prioritzar les regles que s'han utilitzat m\u00e9s sovint o que s\u00f3n m\u00e9s recents.</li> <li>Metarregles: Regles addicionals que determinen com s'han de resoldre els conflictes entre les regles. </li> </ul>"},{"location":"u02/#conclusio","title":"Conclusi\u00f3.","text":"<p>En esta unitat hem vist els conceptes b\u00e0sics sobre models d'IA i la representaci\u00f3 del coneixement. Hem explorat qu\u00e8 \u00e9s un model, quins tipus de models existeixen, i com es poden utilitzar per resoldre problemes en diferents \u00e0mbits. Tamb\u00e9 hem analitzat la import\u00e0ncia de la representaci\u00f3 del coneixement i els requeriments b\u00e0sics per a un sistema de resoluci\u00f3 de problemes. </p> <p>A mesura que avancem en el curs, aprofundirem en els diferents tipus de models d'IA i les t\u00e8cniques de representaci\u00f3 del coneixement, aix\u00ed com en les aplicacions pr\u00e0ctiques d'aquests models en diversos camps. La comprensi\u00f3 d'aquests conceptes \u00e9s fonamental per a desenvolupar sistemes d'IA efectius i eficients que puguen resoldre problemes complexos aplicables a situacions reals i pr\u00e0ctiques de la vida quotidiana.</p>"},{"location":"u02/#exercici-de-raonament-deductiu","title":"Exercici de raonament deductiu.","text":"<p>Intenta crear un senzill SBR per diagnosticar el problema d'un cotxe que no arranca. Defineix una base de coneixement amb regles que representen el coneixement sobre els possibles problemes i solucions. Utilitza l'encadenament cap endavant per inferir possibles causes del problema a partir dels s\u00edmptomes observats.</p> <ul> <li>Quins s\u00f3n els fets inicials?</li> <li>Quines s\u00f3n les regles que podem definir?</li> <li>Com podem aplicar l'encadenament cap endavant per arribar a una conclusi\u00f3?</li> <li>A quines conclusions podem arribar?</li> </ul>"},{"location":"u02/#exercici-de-raonament-inductiu","title":"Exercici de raonament inductiu.","text":"<p>Imagina el seg\u00fcent problema:</p> <p>Una persona que no t\u00e9 feina se jubilar\u00e0 dins de 10 anys. Imagina que cada any que continua sense feina li arriba una oferta de treball que pot ser bona (100\u20ac) o mala (44\u20ac). La probabilitat de que siga bona o mala \u00e9s la mateixa (50%). Si accepta una de les 2 ofertes, haur\u00e0 de treballar fins que se jubile (10 anys a partir de l'any inicial).</p> <p>El que volem saber \u00e9s: hauria d'acceptar feines males en qualsevol moment, per por a no rebre mai cap oferta bona i estar sense feina els 10 anys?</p> <p>Podem intentar solucionar el problema amb raonament inductiu (cap endavant), per\u00f2 \u00e9s molt m\u00e9s senzill fer-ho amb raonament deductiu (cap enrere).</p> <p>Tin en compte les tres opcions:</p> <ul> <li>Acceptar una oferta bona</li> <li>Acceptar una oferta mala</li> <li>Rebutjar l'oferta (siga bona o mala) i esperar una nova oferta l'any seg\u00fcent.</li> </ul> <p>Ho anem a resoldre de forma \"humana\". Com ho fariem en un Sistema Basat en Regles (SBR)? El SBR tindria una base de coneixement amb regles que representen les condicions i accions a prendre en cada any, i el motor d'infer\u00e8ncia aplicaria l'encadenament cap enrere per determinar si acceptar o no una oferta de treball en funci\u00f3 de l'any i les ofertes disponibles. Ho veurem en una pr\u00e0ctica.</p>"},{"location":"u03/","title":"Soluci\u00f3 de problemes mitjan\u00e7ant cerques. Conceptes previs.","text":"<p>En esta unitat did\u00e0ctica treballarem la resoluci\u00f3 de problemes mitjan\u00e7ant cerques. Abans de comen\u00e7ar a veure tipus de cerques i algorismes, anem a repassar en alguns casos, o a introduir en altres, certs conceptes previs necessaris per a entendre la resta de la unitat. En general el que anem a veure s\u00f3n, principalment, estructures i conceptes matem\u00e0tics que ens permeten modelar i implementar, de la manera m\u00e9s eficient, els problemes que volem resoldre, la informaci\u00f3 de qu\u00e8 disposem i les solucions que busquem. </p>"},{"location":"u03/#grafs","title":"Grafs","text":"<p>Un graf \u00e9s una estructura de dades formada per un conjunt de nodes (o v\u00e8rtexs) i un conjunt d'arestes que connecten parells de nodes. Els grafs s\u00f3n \u00fatils per modelar relacions no jer\u00e0rquiques entre objectes, com ara xarxes socials, rutes de transport, connexions d'ordinadors, etc.</p> <p></p> <p>En el cas de l'\u00fas de grafs per a cerques, els nodes poden representar estats o posicions, i les arestes representen les transicions o moviments entre els diferents estats. Aix\u00ed, un problema de cerca pot ser modelat com un graf on volem trobar un cam\u00ed des d'un node inicial fins a un node objectiu.</p> <p>El grau d'un node \u00e9s el nombre d'arestes que estan connectades a ell. Un node amb grau 0 no t\u00e9 connexions, un node amb grau 1 est\u00e0 connectat a un altre node, i aix\u00ed successivament. El grau d'un node \u00e9s important perqu\u00e8 ens ajuda a entendre la seua connexi\u00f3 amb altres nodes en el graf.</p> <p>En la imatge, els nodes de dalt i baix tenen grau 2, ja que estan connectats a dos nodes, mentre que els nodes dels laterals tenen grau 3, ja que estan connectats a tres nodes.</p>"},{"location":"u03/#tipus-de-grafs","title":"Tipus de grafs","text":"<p>Pel que fa a les arestes, els grafs poden ser dirigits o no dirigits.</p> <p>Un graf no dirigit \u00e9s aquell en qu\u00e8 les arestes no tenen una direcci\u00f3 espec\u00edfica; \u00e9s a dir, si hi ha una aresta entre els nodes A i B, es pot anar de A a B i tamb\u00e9 de B a A. En canvi, un graf dirigit t\u00e9 arestes amb una direcci\u00f3 espec\u00edfica, de manera que si hi ha una aresta que apunta de A a B, nom\u00e9s es pot anar de A a B i no al rev\u00e9s. Un graf no dirigit es pot representar tal com hem vist a la imatge anterior. Un graf dirigit seria el seg\u00fcent:</p> <p></p> <p>En un graf dirigit, si de un node nom\u00e9s eixen arestes cap a altres nodes, per\u00f2 ni ha cap aresta que entre en ell, es diu que \u00e9s un node font. Si un node nom\u00e9s t\u00e9 arestes entrant per\u00f2 no eixint, es diu que \u00e9s un node sumider. Aix\u00f2 \u00e9s \u00fatil per a identificar punts d'inici i final en un graf dirigit.</p> <p>Un graf c\u00edclic \u00e9s aquell que cont\u00e9 un cam\u00ed que comen\u00e7a i acaba en el mateix node, passant per altres nodes. \u00c9s a dir, es pot tornar al punt d'inici despr\u00e9s de travessar alguns nodes i arestes. Aix\u00f2 \u00e9s important en molts problemes de cerca on es vol explorar un cicle complet.</p> <p>Un graf ponderat \u00e9s aquell en qu\u00e8 les arestes tenen un valor associat, que pot representar un cost, dist\u00e0ncia o qualsevol altra mesura. Aix\u00f2 \u00e9s \u00fatil quan volem trobar el cam\u00ed m\u00e9s curt o el cam\u00ed amb el menor cost entre dos nodes.</p> <p></p> <p>Un graf complet \u00e9s aquell en qu\u00e8 hi ha una aresta entre cada parell de nodes. \u00c9s a dir, tots els nodes estan connectats entre si. Aix\u00f2 \u00e9s \u00fatil quan volem assegurar-nos que hi ha una connexi\u00f3 directa entre tots els nodes del graf.</p> <p>Un graf connex \u00e9s aquell en qu\u00e8 es pot tra\u00e7ar un cam\u00ed entre qualsevol parell de nodes sense sortir del graf. \u00c9s a dir, no hi ha arestes que connecten nodes que estiguin fora del cam\u00ed tra\u00e7at. Aix\u00f2 \u00e9s important per a garantir que es pot arribar a qualsevol node des d'un altre node. Un graf complet sempre \u00e9s connex, per\u00f2 un graf connex no sempre \u00e9s complet.</p> <p></p> <p>Els grafs ac\u00edclics i dirigits, coneguts com a DAGs (Directed Acyclic Graphs), s\u00f3n molt utilitzats en programaci\u00f3. Per exemple, com veurem m\u00e9s endavant, per  construir arbres de decisi\u00f3.</p>"},{"location":"u03/#un-poc-dhistoria","title":"Un poc d'hist\u00f2ria","text":"<p>Els grafs han estat estudiats des de fa molt de temps, i un dels primers problemes relacionats amb ells \u00e9s el Problema dels set ponts de K\u00f6nigsberg, plantejat per Leonhard Euler al segle XVIII. En aquest problema, es tractava de trobar un cam\u00ed que travessara tots els ponts de la ciutat de K\u00f6nigsberg exactament una vegada (\u00e9s a dir, sense passar dues vegades pel mateix pont). Euler va demostrar que no era possible introdu\u00efnt el concepte de graf euleri\u00e0: es tracta d'un graf on tots els nodes s\u00f3n de grau parell o si hi ha exactament dos nodes de grau imparell. El graf que representava els ponts de K\u00f6nigsberg no era euleri\u00e0, ja que tenia tots els nodes (4) de grau imparell. Aquest problema va portar al desenvolupament de la teoria dels grafs. El cam\u00ed que connecta tots els nodes sense passar dues vegades per la mateixa aresta es coneix com a cam\u00ed euleri\u00e0.</p> <p></p> <p>Una forma alternativa del problema demana que el cam\u00ed passe per tots els ponts i torne al punt d'inici. Un circuit aix\u00ed s'anomena un circuit euleri\u00e0. Existeix un circuit euleri\u00e0 si no hi cap node de grau imparell.</p> <p>Exercici: intenteu dibuixar un sobre obert sense al\u00e7ar el llapis del paper i sense passar dues vegades per la mateixa aresta. Se pot? Per qu\u00e8? I un sobre tancat? I un sobre obert i tancat al mateix temps? </p> <p></p> <p>Ara intenteu fer el mateix amb les tres figures per\u00f2 tampoc podeu passar dues vegades pel mateix node. Quines figures podeu dibuixar i quines no?</p> <p>Si hi ha dos nodes de grau imparell, el cam\u00ed euleri\u00e0 comen\u00e7ar\u00e0 en un d'ells i acabar\u00e0 en l'altre. Si tots els nodes s\u00f3n de grau parell, el cam\u00ed euleri\u00e0 comen\u00e7ar\u00e0 i acabar\u00e0 en el mateix node. Si hi ha m\u00e9s de dos nodes de grau imparell, no hi ha cap cam\u00ed euleri\u00e0 possible.</p> <p>Un circuit que nom\u00e9s passe 1 vegada per cada aresta i per cada node s'anomena circuit hamiltoni\u00e0. Un circuit hamiltoni\u00e0 \u00e9s prou m\u00e9s complicat de trobar (si \u00e9s possible) i la seua base matem\u00e0tica \u00e9s molt complexa.</p>"},{"location":"u03/#representacio-de-grafs-amb-estructures-de-dades","title":"Representaci\u00f3 de grafs amb estructures de dades","text":"<p>Hi ha diverses maneres de representar un graf, les m\u00e9s comunes s\u00f3n:</p> <ul> <li>Matriu d'adjac\u00e8ncia: Una matriu quadrada on l'element a la fila i columna (i, j) indica si hi ha una aresta entre els nodes i i j.</li> <li>Llista d'adjac\u00e8ncia: Una llista on cada element correspon a un node i cont\u00e9 una llista dels nodes als quals est\u00e0 connectat per arestes. Si el graf \u00e9s ponderat, cada element de la llista pot incloure tamb\u00e9 el pes de l'aresta.</li> </ul> <p>Exemple de matriu d'adjac\u00e8ncia:</p> <pre><code>    A B C D\n  A 0 1 1 0\n  B 1 0 0 1\n  C 1 0 0 1\n  D 0 1 1 0\n</code></pre> <p>En un graf ponderat, en lloc de posar un 1 on hi ha una aresta posariem el seu pes:</p> <pre><code>    A B C D\n  A 0 2 3 0\n  B 2 0 0 1\n  C 3 0 0 4\n  D 0 1 4 0\n</code></pre> <p>Exemple de llista d'adjac\u00e8ncia sense arestes ponderades:</p> <pre><code>A: B, C\nB: A, D\nC: A, D\nD: B, C\n</code></pre> <p>Amb arestes ponderades:</p> <pre><code>A: (B,2), (C,3)\nB: (A,2), (D,1)\nC: (A,3), (D,4)\nD: (B,1), (C,4)\n</code></pre> <p>En este cas la matriu \u00e9s sim\u00e8trica, ja que les arestes s\u00f3n no dirigides. En un graf dirigit, la matriu no seria sim\u00e8trica, ja que les arestes tindrien una direcci\u00f3 espec\u00edfica. Per exemple, el seg\u00fcent graf dirigit:</p> <p></p> <p>Se representaria amb una llista d'adjac\u00e8ncia com la seg\u00fcent:</p> <pre><code>A: (B,5), (C,9)\nB: (D,2), (E,7)\nC: (D,3)\nD: (A,1), (E,13)\nE: \n</code></pre> <p>Aquesta representaci\u00f3 \u00e9s \u00fatil per a cerques, ja que permet accedir r\u00e0pidament als nodes i les seues connexions. La matriu d'adjac\u00e8ncia \u00e9s m\u00e9s eficient per a grafs densos (amb moltes arestes), mentre que la llista d'adjac\u00e8ncia \u00e9s m\u00e9s eficient per a grafs amb poques arestes perqu\u00e8 evitem que els valors 0 ocupen espai en mem\u00f2ria. Compareu la llista que hem vist abans amb la seg\u00fcent matriu d'adjac\u00e8ncia que \u00e9s equivalent:</p> <pre><code>    A B C D E\n  A 0 5 9 0 0\n  B 0 0 0 2 7\n  C 0 0 0 3 0\n  D 1 0 0 0 13\n  E 0 0 0 0 0\n</code></pre> <p>Potser en aquest exemple no trobeu gran difer\u00e8ncia, per\u00f2 imagineu el cas que el graf tinguera 1000 nodes i nom\u00e9s 10 arestes, la matriu d'adjac\u00e8ncia ocuparia 1.000.000 de posicions (1.000 x 1.000), mentre que la llista d'adjac\u00e8ncia nom\u00e9s ocuparia espai per a les 10 arestes.</p>"},{"location":"u03/#exemple-de-graf-en-python","title":"Exemple de graf en Python","text":"<p>Per a representar un graf en Python, podem utilitzar una classe que continga una llista d'adjac\u00e8ncia. Aqu\u00ed teniu un exemple senzill:</p> <pre><code>class Graf:\n    def __init__(self):\n        self.adjacencia = {}\n\n    def afegir_aresta(self, node1, node2, pes=1):\n        # la funci\u00f3 permet afegir una aresta entre dos nodes amb un pes opcional (per defecte \u00e9s 1)\n        # Si els nodes no existeixen, els inicialitzem\n        # node1 i node2 poden ser qualsevol tipus de dades (n\u00fameros, cadenes, etc.) Les guardem com a claus del diccionari\n        if node1 not in self.adjacencia:\n            self.adjacencia[node1] = []\n        if node2 not in self.adjacencia: # nom\u00e9s si el graf \u00e9s no dirigit\n            self.adjacencia[node2] = []\n        # Afegim l'aresta a la llista d'adjac\u00e8ncia\n        # Si el graf \u00e9s dirigit, nom\u00e9s afegim l'aresta en una direcci\u00f3\n        # Si \u00e9s no dirigit, afegim l'aresta en ambdues, com en este cas\n        self.adjacencia[node1].append((node2, pes))\n        self.adjacencia[node2].append((node1, pes))  # Si el graf \u00e9s no dirigit\n\n    def mostrar(self):\n        for node, connexions in self.adjacencia.items():\n            print(f\"{node}: {connexions}\")\n</code></pre>"},{"location":"u03/#tipus-de-problemes-habituals-amb-grafs","title":"Tipus de problemes habituals amb grafs","text":"<p>Els grafs s\u00f3n una eina molt potent per a resoldre diversos tipus de problemes. Alguns dels m\u00e9s comuns s\u00f3n:</p> <ul> <li>Cerca de camins m\u00ednims: Trobar el cam\u00ed m\u00e9s curt entre dos nodes.</li> <li>Cerca de connexions: Determinar si hi ha un cam\u00ed entre dos nodes.</li> <li>Cerca de components connexos: Identificar grups de nodes que estan connectats entre si.</li> <li>Cerca de cicles: Determinar si hi ha un cicle en un graf.</li> <li>Cerca de camins eulerians i hamiltonians: Trobar camins que compleixen les condicions espec\u00edfiques dels camins i circuits eulerians i hamiltonians.</li> <li>Colorejat de grafs: nombre m\u00ednim de colors per a pintar els nodes d'un graf de manera que dos nodes adjacents no tinguin el mateix color.</li> <li>Ordenaci\u00f3 topol\u00f2gica: trobar un ordre lineal dels nodes d'un graf dirigit ac\u00edclic.</li> <li>Flux m\u00e0xim: trobar el flux m\u00e0xim entre dos nodes.</li> </ul> <p>M\u00e9s endavant veurem quins algorismes podem utilitzar per a resoldre aquests problemes de manera eficient. Per ara, \u00e9s important entendre com es representen els grafs i quins s\u00f3n els seus components b\u00e0sics, ja que aix\u00f2 ens permetr\u00e0 aplicar els algorismes de cerca de manera efectiva.</p>"},{"location":"u03/#arbres","title":"Arbres","text":"<p>Un arbre \u00e9s un tipus especial de graf que t\u00e9 una estructura jer\u00e0rquica. Un arbre est\u00e0 format per nodes, on cada node pot tenir zero o m\u00e9s nodes fills, per\u00f2 nom\u00e9s un node pare. El node superior es coneix com a arrel de l'arbre, i els nodes sense fills es coneixen com a fulles.</p> <p>Un arbre \u00e9s un graf amb les seg\u00fcents caracter\u00edstiques:</p> <ul> <li>\u00c9s connex: hi ha un cam\u00ed entre qualsevol parell de nodes.</li> <li>\u00c9s ac\u00edclic: no cont\u00e9 cicles (en este cas, arestes d'un node a ell mateix).</li> <li>No \u00e9s dirigit: les arestes no tenen una direcci\u00f3 espec\u00edfica.</li> <li>\u00c9s \u00fanic: hi ha un cam\u00ed \u00fanic entre qualsevol parell de nodes.</li> </ul> <p>En general els arbres s'utilitzen per a representar estructures jer\u00e0rquiques, com ara sistemes de fitxers, organigrames, arbres de decisi\u00f3, etc.</p> <p></p>"},{"location":"u03/#tipus-darbres","title":"Tipus d'arbres","text":"<ul> <li>Generals: Un arbre general \u00e9s aquell en qu\u00e8 cada node pot tenir qualsevol nombre de fills. \u00c9s el tipus d'arbre m\u00e9s com\u00fa i es pot utilitzar per a representar estructures jer\u00e0rquiques complexes.</li> <li>Binari: Un arbre binari \u00e9s aquell en qu\u00e8 cada node pot tenir com a m\u00e0xim dos fills, anomenats fill esquerre i fill dret. Els arbres binaris s\u00f3n molt utilitzats en inform\u00e0tica, ja que permeten una cerca eficient i una representaci\u00f3 compacta de dades.</li> <li>Arbres binaris de cerca (BST): Un arbre binari de cerca \u00e9s un arbre binari en qu\u00e8 els nodes estan ordenats de manera que el valor de cada node \u00e9s major que els valors dels seus fills esquerre i menor que els valors dels seus fills dret. Aix\u00f2 permet una cerca eficient de valors.</li> <li>n-ari: Un arbre n-ari \u00e9s aquell en qu\u00e8 cada node pot tenir com a m\u00e0xim n fills. \u00c9s una generalitzaci\u00f3 dels arbres binaris i es pot utilitzar per a representar estructures jer\u00e0rquiques amb m\u00e9s de dos fills per node.</li> <li>Heaps: s\u00f3n arbres binaris balancejats que compleixen una propietat addicional. Els heaps es poden utilitzar per a implementar cues de prioritat.</li> </ul> <p>En general els arbres m\u00e9s utilitzats en algorismes de cerca s\u00f3n els arbres binaris de cerca i els arbres n-aris. Sobretot els BST s\u00f3n especialment \u00fatils per a cerques eficients, ja que permeten una cerca, inserci\u00f3 i eliminaci\u00f3 de valors en temps O(log n) en el millor dels casos.</p> <p></p>"},{"location":"u03/#representacio-darbres-amb-estructures-de-dades","title":"Representaci\u00f3 d'arbres amb estructures de dades","text":"<p>Els arbres es poden representar de diverses maneres, encara que la m\u00e9s comuna \u00e9s mitjan\u00e7ant una llista enlla\u00e7ada on cada node t\u00e9 un valor i refer\u00e8ncies als seus nodes fills. Per exemple, un node d'un arbre binari pot tenir la seg\u00fcent estructura:</p> <pre><code>class Node:\n    def __init__(self, valor):\n        self.valor = valor\n        self.fill_esquerre = None\n        self.fill_dret = None\n</code></pre> <p>I ara, implementar un arbre binari de cerca seria tan senzill com crear una classe que continga un node arrel i m\u00e8todes per a afegir nodes, cercar valors, etc. Per exemple:</p> <pre><code>class ArbreBinari:\n    def __init__(self):\n        self.arrel = None # inicialitzem l'arbre amb l'arrel com a None (buit)\n\n    def afegir(self, valor):\n        if self.arrel is None: # si l'arbre est\u00e0 buit, el nou valor es converteix en l'arrel\n            self.arrel = Node(valor)\n        else: # si l'arbre ja t\u00e9 nodes, afegim el valor de manera recursiva per a col\u00b7locar-lo en la posici\u00f3 correcta\n            self._afegir_recursiu(self.arrel, valor)\n\n    def _afegir_recursiu(self, node, valor):\n        if valor &lt; node.valor: # si el valor \u00e9s menor que el node actual, anem al fill esquerre\n            if node.fill_esquerre is None: # si no hi ha fill esquerre, inserim el nou node com a fill esquerre\n                node.fill_esquerre = Node(valor)\n            else: # si ja hi ha fill esquerre, repetim l'operaci\u00f3 amb el fill esquerre\n                self._afegir_recursiu(node.fill_esquerre, valor)\n        else: # si el valor \u00e9s major o igual que el node actual, anem al fill dret\n            if node.fill_dret is None: # si no hi ha fill dret, inserim el nou node com a fill dret\n                node.fill_dret = Node(valor)\n            else: # si ja hi ha fill dret, repetim l'operaci\u00f3 amb el fill dret\n                self._afegir_recursiu(node.fill_dret, valor)\n</code></pre> <ul> <li>L'arbre t\u00e9 un node arrel, inicialment buit.</li> <li>El m\u00e8tode <code>afegir</code> permet afegir un valor a l'arbre. Si l'arbre est\u00e0 buit, el valor afegit se converteix en el node arrel.</li> <li>Si l'arbre ja t\u00e9 nodes, el m\u00e8tode <code>_afegir_recursiu</code> s'encarrega de col\u00b7locar el nou valor en la posici\u00f3 correcta segons les regles d'un arbre binari de cerca: <ul> <li>si el valor \u00e9s menor que el node actual i no hi ha fill esquerre, inserim el nou node com a fill esquerre del node actual</li> <li>si el valor \u00e9s menor que el node actual i ja hi ha fill esquerre, repetim l'operaci\u00f3 afegir_recursiu amb el fill esquerre</li> <li>si el valor \u00e9s major que el node actual i no hi ha fill dret, inserim el nou node com a fill dret del node actual</li> <li>si el valor \u00e9s major que el node actual i ja hi ha fill dret, repetim l'operaci\u00f3 afegir_recursiu amb el fill dret</li> </ul> </li> </ul>"},{"location":"u03/#recorregut-darbres","title":"Recorregut d'arbres","text":"<p>Per rec\u00f3rrer un arbre, hi ha diverses estrat\u00e8gies, les m\u00e9s comunes s\u00f3n:</p> <ul> <li>Preordre: Visitem el node actual, despr\u00e9s el fill esquerre i finalment el fill dret. Aix\u00f2 \u00e9s \u00fatil per a crear una c\u00f2pia de l'arbre o per a imprimir els nodes en ordre.</li> <li>Inordre: Visitem primer el fill esquerre, despr\u00e9s el node actual i finalment el fill dret. Aix\u00f2 \u00e9s \u00fatil per a obtenir els valors d'un arbre binari de cerca en ordre ascendent.</li> <li>Postordre: Visitem primer el fill esquerre, despr\u00e9s el fill dret i finalment el node actual. Aix\u00f2 \u00e9s \u00fatil per a eliminar nodes de l'arbre o per a calcular valors agregats.</li> </ul> <p>Si l'arbre \u00e9s un arbre binari de cerca:</p> <ul> <li>el recorregut inordre ens donar\u00e0 els valors en ordre ascendent. Aix\u00f2 \u00e9s perqu\u00e8 els valors dels nodes del fill esquerre s\u00f3n sempre menors que el valor del node actual, i els valors dels nodes del fill dret s\u00f3n sempre majors.</li> <li>el recorregut preordre ens donar\u00e0 els valors en l'ordre en qu\u00e8 es van afegir a l'arbre, comen\u00e7ant per l'arrel.</li> <li>el recorregut postordre ens donar\u00e0 els valors en l'ordre en qu\u00e8 es van eliminar de l'arbre, comen\u00e7ant pels nodes fulles i acabant per l'arrel.</li> <li>si volem trobar un valor concret, podem utilitzar un recorregut binaritzat: com que els arbres binaris de cerca estan ordenats, podem comparar el valor que busquem amb el valor del node actual i decidir si continuar buscant al fill esquerre o al fill dret. Aix\u00f2 ens permet reduir el nombre de nodes que hem de visitar i fer la cerca m\u00e9s eficient.</li> </ul>"},{"location":"u03/#exercici","title":"Exercici","text":"<p>Fes un programa en Python que cree l'arbre que hem vist en la imatge anterior, amb exactamente el mateix contingut, i fes una funcio que mostre els valors en ordre ascendent i una altra en ordre descendent.</p>"},{"location":"u03/#llistes-piles-i-cues","title":"Llistes, piles i cues","text":"<p>Les llistes, piles i cues s\u00f3n estructures de dades fonamentals que ens permeten emmagatzemar i gestionar col\u00b7leccions d'elements de manera eficient. Cada una d'elles t\u00e9 les seues pr\u00f2pies caracter\u00edstiques i usos espec\u00edfics que veurem a continuaci\u00f3.</p>"},{"location":"u03/#llistes","title":"Llistes","text":"<p>Una llista \u00e9s una estructura de dades que permet emmagatzemar una col\u00b7lecci\u00f3 d'elements. Les llistes poden ser din\u00e0miques, \u00e9s a dir, poden canviar de mida durant l'execuci\u00f3 del programa, o est\u00e0tiques, on la mida es defineix en el moment de la creaci\u00f3. </p> <p>En Python les llistes s\u00f3n m\u00e9s \u00fatils que els vectors quan treballem amb dades molt vol\u00e0tils, ja que les llistes poden canviar de mida i permeten afegir o eliminar elements amb m\u00e9s facilitat</p> <p>Una llista enlla\u00e7ada \u00e9s una llista on cada element (o node) cont\u00e9 un valor i una refer\u00e8ncia al seg\u00fcent element de la llista. Aix\u00f2 permet una inserci\u00f3 i eliminaci\u00f3 eficient d'elements, encara que accedir a un element espec\u00edfic pot ser m\u00e9s lent que en una llista est\u00e0tica ja que el recorregut sempre \u00e9s sequencial. Sempre ser\u00e0 m\u00e9s \u00fatil, per tant, si hi ha un cert tipus d'ordenaci\u00f3.</p> <p></p> <p>En Python, podem implementar una llista enlla\u00e7ada utilitzant classes per als nodes i la llista. Cada node t\u00e9 un valor i una refer\u00e8ncia al seg\u00fcent node. </p> <pre><code>class Node:\n    def __init__(self, valor):\n        self.valor = valor\n        self.seguent = None\n\nclass LlistaEnlla\u00e7ada:\n    def __init__(self):\n        self.cap = None\n\n    def afegir(self, valor):\n        nou_node = Node(valor)\n        if not self.cap:\n            self.cap = nou_node\n        else:\n            node_actual = self.cap\n            while node_actual.seguent:\n                node_actual = node_actual.seguent\n            node_actual.seguent = nou_node\n\n    def imprimir(self):\n        node_actual = self.cap\n        while node_actual:\n            print(node_actual.valor)\n            node_actual = node_actual.seguent\n</code></pre> <p>Si volem mantindre la llista ordenada, hem d'implementar m\u00e8todes per a inserir un node en una posici\u00f3 espec\u00edfica. Potser tamb\u00e9 voldrem eliminar nodes. Tot aix\u00f2 ho aconseguim simplement canviant les refer\u00e8ncies dels nodes implicats.</p> <ul> <li>per a inserir un node, recorrem la llista fins a trobar la posici\u00f3 correcta. El node seg\u00fcent del node anterior on volem fer la inserci\u00f3 ser\u00e0 el node seg\u00fcent del nou node. El node seg\u00fcent del node anterior ser\u00e0 el nou node.</li> <li>per a eliminar un node, recorrem la llista fins a trobar el node que volem eliminar. Modificarem la refer\u00e8ncia del node anterior per a que apunte al seg\u00fcent del node eliminar (aix\u00ed ens saltem el node eliminat).</li> </ul> <p>En Python tenim la classe List per a guardar col\u00b7leccions d'elements. Aquesta classe proporciona m\u00e8todes per a afegir, eliminar i accedir als elements de manera eficient. Per a llistes enlla\u00e7ades no hi ha cap estructura concreta per\u00f2 ja hem vist com implementar-la utilitzant classes.</p> <p>En Python tamb\u00e9 podem implementar una llista utilitzant la classe collections.deque. Amb deque podem crear una llista doblement enlla\u00e7ada (cada element guarda dues refer\u00e8ncies, al seg\u00fcent i tamb\u00e9 a l'anterior) que permet afegir i eliminar elements tant pel principi (appendleft) com pel final (append) de la llista. Aix\u00f2 \u00e9s \u00fatil per a implementar estructures de dades com piles i cues, que veurem m\u00e9s endavant. Per a afegir elements en qualsevol posici\u00f3 hem de fer com hem vist abans, recorrent la llista fins a trobar la posici\u00f3 correcta i afegint/eliminant el node corresponent.</p>"},{"location":"u03/#piles","title":"Piles","text":"<p>Una pila \u00e9s un tipus especial de llista que segueix el principi LIFO (Last In, First Out). \u00c9s a dir, l'\u00faltim element afegit \u00e9s el primer en ser eliminat. Aix\u00f2 implica que els elements s'afegixen i s'eliminen sempre pel mateix extrem de la pila.</p> <p></p> <p>Si volem implementar una pila utilitzant deque, afegirem i eliminarem els elements sempre pel final de la llista.</p> <pre><code>from collections import deque\n\npila = deque()\n\n# Afegir elements a la pila\npila.append(1)\npila.append(2)\npila.append(3)\n\n# Eliminar elements de la pila\nprint(pila.pop())  # mostra el 3 i l'elimina\nprint(pila.pop())  # mostra el 2 i l'elimina\nprint(pila.pop())  # mostra el 1 i l'elimina\n</code></pre>"},{"location":"u03/#cues","title":"Cues","text":"<p>Una cua \u00e9s un altre tipus especial de llista que segueix el principi FIFO (First In, First Out). \u00c9s a dir, el primer element afegit \u00e9s el primer en ser eliminat. Aix\u00f2 implica que els elements s'afegiran pel principi de la cua i s'eliminaran pel final. Ac\u00ed podem utilitzar tamb\u00e9 la classe deque afegint els elements amb append i eliminant-los amb popleft.</p> <p></p> <pre><code>from collections import deque\n\ncua = deque()\n\n# Afegir elements a la cua\ncua.append(1)\ncua.append(2)\ncua.append(3)\n\n# Eliminar elements de la cua\nprint(cua.popleft())  # mostra el 1 i l'elimina\nprint(cua.popleft())  # mostra el 2 i l'elimina\nprint(cua.popleft())  # mostra el 3 i l'elimina\n</code></pre>"},{"location":"u03/#complexitat-computacional","title":"Complexitat computacional","text":"<p>La complexitat computacional \u00e9s una mesura de l'efici\u00e8ncia d'un algorisme en termes de temps i espai que necessita per a resoldre un problema. \u00c9s important perqu\u00e8 ens ajuda a comparar diferents algorismes i a triar el m\u00e9s adequat per a un problema concret.</p>"},{"location":"u03/#complexitat-temporal","title":"Complexitat temporal","text":"<p>La complexitat temporal \u00e9s una mesura de l'efici\u00e8ncia d'un algorisme en funci\u00f3 de la quantitat de dades amb les quals treballem. Normalment utilitzem la notaci\u00f3 asint\u00f2tica per a descriure la complexitat temporal, que s'escriu O(x) on x \u00e9s una funci\u00f3 sobre la quantitat d'elements. \u00c9s important saber que la complexitat temporal no ens diu el temps exacte que trigar\u00e0 un algorisme, sin\u00f3 com creix el temps d'execuci\u00f3 a mesura que augmenta la quantitat de dades.</p> <p>Anem a veure un exemple senzill. Imaginem un vector. Si volem buscar un element i sabem que quina posici\u00f3 est\u00e0, la complexitat temporal seria O(1) perqu\u00e8 nom\u00e9s necessitem un temps per a trobar-lo. Si no sabem la posici\u00f3, la complexitat temporal seria O(n), que vol dir que en el pitjor dels casos necessitarem tants passos com elements t\u00e9 el vector.</p> <p>Un exemple un poc m\u00e9s complicat per\u00f2 senzill d'entendre. En un arbre binari de cerca, la complexitat temporal seria O(log n), ja que cada vegada que comparem un valor redu\u00efm a la meitat el nombre de nodes que hem de visitar. Teniu en compte que, en inform\u00e0tica, la notaci\u00f3 log (sense base) normalment es refereix al logaritme en base 2, ja que estem parlant de cerques bin\u00e0ries. Aix\u00f2 vol dir que si tenim un arbre amb 1000 nodes, necessitarem com a m\u00e0xim 10 passos per a trobar un valor (ja que 2^10 = 1024).</p> <p>En el pitjor dels casos, si un arbre est\u00e0 desbalancejat i t\u00e9 una forma lineal (com una llista), la complexitat temporal seria O(n) igual que en qualsevol vector.</p>"},{"location":"u03/#complexitat-espacial","title":"Complexitat espacial","text":"<p>La complexitat espacial \u00e9s una mesura de l'efici\u00e8ncia d'un algorisme en funci\u00f3 de la quantitat d'espai de mem\u00f2ria que necessita per a resoldre un problema. Igual que amb la complexitat temporal, utilitzem la notaci\u00f3 asint\u00f2tica per a descriure la complexitat espacial.</p> <p>La complexitat espacial se calcula en funci\u00f3 de la quantitat de dades per\u00f2 tamb\u00e9 de les estructures i algorismes que utilitzem. Per exemple, si utilitzem un vector per a emmagatzemar dades, la complexitat espacial seria O(n), ja que necessitem espai per a cada element del vector. Si utilitzem una llista enlla\u00e7ada, la complexitat espacial tamb\u00e9 seria O(n), per\u00f2 amb un cost addicional per a les refer\u00e8ncies als nodes. Ho anirem veient a mesura que anem treballant diferents algorismes.</p>"},{"location":"u03/#exercicis","title":"Exercicis","text":"<p>En un document adjunt teniu una s\u00e8rie d'exercicis per a practicar els conceptes que hem vist en esta unitat.</p>"},{"location":"u03/cerques/","title":"Algorismes de cerca","text":""},{"location":"u03/cerques/#introduccio","title":"Introducci\u00f3","text":"<p>En l'apartat anterior hem vist com treballar amb diferents estructures de dades i com aquestes poden ser \u00fatils per a la resoluci\u00f3 de problemes. En aquest apartat, ens centrarem en els algorismes de cerca, que s\u00f3n fonamentals per explorar les dades que tenim i trobar solucions a problemes complexos. En funci\u00f3 del tipus de problema a resoldre triarem unes estructures de dades i uns algorismes de cerca. Per podem triar b\u00e9, necessitem con\u00e9ixer les caracter\u00edstiques de cada algorisme, com es comporten en diferents situacions, quines s\u00f3n els seus avantatges i inconvenients, i per a quins tipus de problemes s\u00f3n m\u00e9s adequats.</p>"},{"location":"u03/cerques/#resolucio-de-problemes","title":"Resoluci\u00f3 de problemes","text":"<p>Com que tot el que anem a veure s'utilitza en la resoluci\u00f3 de problemes, \u00e9s important que tinguem clar qu\u00e8 \u00e9s un problema i com es pot representar. En aquest apartat, definirem qu\u00e8 \u00e9s un problema i com es pot representar mitjan\u00e7ant un espai d'estats. A m\u00e9s, veurem com els algorismes de cerca ens ajuden a explorar aquest espai d'estats per trobar solucions. M\u00e9s endavant tamb\u00e9 analitzarem altres tipus de cerques que no treballen estrictament amb espais d'estats.</p>"},{"location":"u03/cerques/#que-es-un-problema","title":"Qu\u00e8 \u00e9s un problema?","text":"<p>En el context de la intel\u00b7lig\u00e8ncia artificial i la inform\u00e0tica, un problema es pot definir com una situaci\u00f3 inicial juntament amb una condici\u00f3 objectiu que volem assolir mitjan\u00e7ant una seq\u00fc\u00e8ncia d'accions. Aquestes accions ens portaran des de la situaci\u00f3 inicial fins a la situaci\u00f3 objectiu. No tots els problemes s\u00f3n iguals, per\u00f2 en general \u00e9s una bona manera de comen\u00e7ar a pensar en la resoluci\u00f3 de problemes. Ja en veurem d'altres.</p> <p>Un problema d'aquest tipus sol estar compost de quatre elements principals:</p> <ul> <li>L'estat inicial: La configuraci\u00f3 del sistema en el punt de partida.</li> <li>L'objectiu o estat final: La configuraci\u00f3 que volem assolir.</li> <li>Les accions o operadors: Les possibles transicions que permeten moure's d'un estat a un altre.</li> <li>Les restriccions: Les condicions que les solucions han de complir.</li> </ul>"},{"location":"u03/cerques/#lespai-destats","title":"L'espai d'estats","text":"<p>L'espai d'estats \u00e9s una representaci\u00f3 abstracta de totes les possibles configuracions que poden assolir-se a partir de la situaci\u00f3 inicial mitjan\u00e7ant les accions disponibles. Cada estat representa una configuraci\u00f3 \u00fanica i les transicions entre estats es defineixen mitjan\u00e7ant les accions.</p> <p>Aquest espai es pot visualitzar com un graf on cada node representa un estat i cada aresta representa una transici\u00f3 entre estats. L'objectiu de la cerca, en aquest tipus de problemes, \u00e9s trobar un cam\u00ed en el graf que ens permeta anar de l'estat inicial a l'estat objectiu.</p> <p>Exemples d'espais d'estats poden ser:</p> <ul> <li>El tauler d'un joc d'escacs, on cada posici\u00f3 legal de les peces representa un estat, i cada moviment legal d'una pe\u00e7a \u00e9s una transici\u00f3</li> <li>Un laberint, on cada cel\u00b7la \u00e9s un estat i els camins entre cel\u00b7les s\u00f3n les transicions.</li> <li>Un problema de ruta, on cada ubicaci\u00f3 geogr\u00e0fica \u00e9s un estat i les carreteres s\u00f3n les transicions.</li> </ul> <p>Per exemple, en el problema del trencaclosques de les vuit reines, cada estat \u00e9s una configuraci\u00f3 de les reines sobre el tauler, i les accions s\u00f3n moviments de les reines que no violen les regles del joc.</p> <p>El problema de les vuit reines \u00e9s un problema cl\u00e0ssic d'intel\u00b7lig\u00e8ncia artificial on l'objectiu \u00e9s col\u00b7locar vuit reines en un tauler d'escacs de manera que cap reina pugui atacar a una altra. Aix\u00f2 implica que no poden compartir la mateixa fila, columna o diagonal.</p>"},{"location":"u03/cerques/#algorismes-de-cerca-en-lespai-destats","title":"Algorismes de cerca en l'espai d'estats","text":"<p>Els algorismes de cerca s'utilitzen per explorar l'espai d'estats amb l'objectiu de trobar una seq\u00fc\u00e8ncia d'accions que ens porten a la situaci\u00f3 objectiu. Aquests algorismes poden ser classificats en cerques no informades i cerques informades o heur\u00edstiques, depenent de si utilitzen o no informaci\u00f3 addicional per guiar la cerca.</p> <p>Els algorismes de cerca en l'espai d'estats poden ser de diferents tipus, depenent de com exploren el graf d'estats. Alguns dels algorismes m\u00e9s comuns inclouen:</p> <ul> <li>Cerca en ampl\u00e0ria: Explora tots els nodes a un nivell de profunditat abans de passar als nodes del seg\u00fcent nivell.</li> <li>Cerca en profunditat: Explora tant com sigui possible al llarg de cada branca abans de retrocedir.</li> <li>Cerca en profunditat limitada: Similar a la cerca en profunditat, per\u00f2 amb un l\u00edmit de profunditat.</li> <li>Cerca en profunditat iterativa: Realitza cerques en profunditat amb l\u00edmits successivament creixents.</li> <li>Cerca de cost uniforme: Explora els nodes en funci\u00f3 del cost acumulat des de l'inici.</li> <li>Cerca A*: Utilitza una funci\u00f3 de cost combinada que inclou tant el cost acumulat com una estimaci\u00f3 heur\u00edstica del cost restant.</li> </ul> <p>Anirem veient cadascun d'aquests algorismes en detall, incloent els seus avantatges i inconvenients, aix\u00ed com exemples d'aplicaci\u00f3. Ara, de moment, anem a introduir un altre concepte important. Les cerques poden ser informades o no informades. Podr\u00edem dir que les no informades s\u00f3n com anar a cegues provant alternatives, mentre que les informades utilitzen informaci\u00f3 addicional per guiar d'alguna manera la cerca cap a la soluci\u00f3.</p>"},{"location":"u03/cerques/#cerques-no-informades","title":"Cerques no informades","text":"<p>Les cerques no informades, tamb\u00e9 conegudes com cerques a cegues, no utilitzen informaci\u00f3 addicional sobre el problema m\u00e9s enll\u00e0 de les definicions b\u00e0siques dels estats i les transicions. Aquestes cerques exploren l'espai d'estats de manera sistem\u00e0tica. Inclouen la major part dels algorismes que hem enumerat abans:</p> <ul> <li>Cerca en ampl\u00e0ria</li> <li>Cerca en profunditat</li> <li>Cerca en profunditat limitada</li> <li>Cerca en profunditat iterativa</li> </ul> <p>Les cerques no informades s\u00f3n independents del problema en el sentit que no fan \u00fas de cap informaci\u00f3 espec\u00edfica sobre la distribuci\u00f3 dels estats ni sobre l'objectiu final. Aix\u00f2 les fa generals per\u00f2 sovint ineficients, ja que poden explorar moltes parts de l'espai d'estats que no s\u00f3n rellevants per trobar la soluci\u00f3.</p>"},{"location":"u03/cerques/#cerca-en-amplaria","title":"Cerca en ampl\u00e0ria","text":"<p>La cerca en ampl\u00e0ria explora tots els nodes a un determinat nivell de profunditat abans de passar als nodes del seg\u00fcent nivell. Aquesta t\u00e8cnica garanteix trobar la soluci\u00f3 m\u00e9s curta per\u00f2 pot ser ineficient pel que fa a l'\u00fas de mem\u00f2ria.</p> <p>Aquest algorisme funciona utilitzant una cua, afegint els nodes fills d'un node abans d'expandir el seg\u00fcent node de la cua. \u00c9s complet, \u00e9s a dir, troba una soluci\u00f3 si n'hi ha una, i \u00e9s \u00f2ptim si el cost de cada pas \u00e9s igual. La principal limitaci\u00f3 \u00e9s el seu alt requeriment de mem\u00f2ria, especialment en espais d'estats amb un gran factor de ramificaci\u00f3.</p> <p>Estats repetits</p> <p>En la cerca en ampl\u00e0ria, \u00e9s important gestionar els estats repetits per evitar l'exploraci\u00f3 innecess\u00e0ria de nodes ja visitats. Aix\u00f2 es pot fer mantenint una llista de nodes ja explorats (CLOSED) i una llista de nodes pendents d'explorar (OPEN). Quan es genera un nou node, es comprova si ja est\u00e0 en CLOSED o OPEN abans d'afegir-lo a OPEN.</p> <p>La llista OPEN se pot implementar com una cua de prioritats. S'extrau l'element de la cua amb la m\u00e0xima prioritat d'acord amb una funci\u00f3 <code>f(n)</code> que ens torna un valor associat a cada node <code>n</code>. En la cerca en ampl\u00e0ria, aquesta funci\u00f3 pot ser simplement la profunditat del node, ja que es vol explorar primer els nodes m\u00e9s propers a l'arrel. En una cerca no informada, aquesta funci\u00f3 no utilitza cap informaci\u00f3 addicional sobre l'objectiu. En la cerca en ampl\u00e0ria la funci\u00f3 f(n) ens diu simplement quina \u00e9s la profunditat del node perqu\u00e8 no tenim m\u00e9s informaci\u00f3 sobre el seu cost. Ja veurem com podem aplicar-la en cerques informades.</p> <p>Veiem com funcionaria aquest proc\u00e9s amb el seg\u00fcent pseudocodi:</p> <pre><code>function GRAPH-SEARCH (problema) return una soluci\u00f3 o una fallada\n  Inicialitzar la llista OPEN amb l'estat inicial del problema\n  Inicialitzar la llista CLOSED a buit\n  do\n    if OPEN est\u00e0 buida \n      then return fallada\n    p &lt;- pop (llista OPEN)\n    afegir p a la llista CLOSED\n    if p = estat final \n      then return soluci\u00f3 p\n    generar fills de p\n    per a cada fill n de p :\n      aplicar f(n)\n      if n no est\u00e0 en CLOSED then\n        if n no est\u00e0 en OPEN o (n est\u00e0 repetit en OPEN i f(n) \u00e9s millor que el valor del nodeen OPEN) \n          then inserir n en ordre creixent de f(n) en OPEN*\n      else f(n) \u00e9s millor que el valor del node repetit en CLOSED \n        then escollir entre re-expandir n (inserir-ho en OPEN) o descartar-lo\n  enddo\n* Com estem interessats a trobar \u00fanicament la primera soluci\u00f3, es pot eliminar n\u2019 de la llista OPEN\n</code></pre>"},{"location":"u03/cerques/#cerca-en-profunditat","title":"Cerca en profunditat","text":"<p>La cerca en profunditat explora tant com siga possible al llarg de cada branca abans de retrocedir. Aquest m\u00e8tode utilitza menys mem\u00f2ria per\u00f2 pot no trobar la soluci\u00f3 m\u00e9s curta i pot caure en cicles infinits si no es controla.</p> <p>L'algorisme utilitza una pila per gestionar els nodes a explorar, afegint els fills del node actual al principi de la pila. \u00c9s m\u00e9s eficient en termes de mem\u00f2ria comparat amb la cerca en ampl\u00e0ria, per\u00f2 pot explorar camins molt llargs que no condueixen a una soluci\u00f3, especialment en espais d'estats amb molta profunditat.</p> <p>Pseudocodi:</p> <pre><code>Cerca_en_profunditat(estat_inicial):\n  crear pila buida S\n  afegir estat_inicial a S\n  mentre S no est\u00e0 buida:\n    estat_actual = treure de S\n    si estat_actual \u00e9s l'estat_objectiu:\n      retornar el cam\u00ed a estat_actual\n    per cada ve\u00ed de estat_actual:\n      si ve\u00ed no est\u00e0 visitat:\n        marcar ve\u00ed com visitat\n        afegir ve\u00ed a S\n  retornar cap_soluci\u00f3\n</code></pre>"},{"location":"u03/cerques/#cerca-en-profunditat-amb-backtracking","title":"Cerca en profunditat amb backtracking","text":"<p>La cerca en profunditat amb backtracking \u00e9s una variant de la cerca en profunditat que permet gestionar l'exploraci\u00f3 de l'espai d'estats de manera m\u00e9s eficient. Aquest m\u00e8tode utilitza una pila per gestionar els nodes a explorar i una llista per emmagatzemar els nodes visitats. Quan es troba una soluci\u00f3, es retrocedeix per trobar altres solucions possibles.</p> <p>Aquesta t\u00e8cnica \u00e9s \u00fatil en problemes on hi ha m\u00faltiples solucions possibles o on es vol trobar la millor soluci\u00f3. Per exemple, en el problema de les vuit reines, es poden trobar totes les solucions possibles amb aquest m\u00e8tode.</p> <p>Pseudocodi:</p> <pre><code>Cerca_en_profunditat_backtracking(estat_inicial):\n  crear pila buida S\n  crear llista buida visitats\n  afegir estat_inicial a S\n  mentre S no est\u00e0 buida:\n    estat_actual = treure de S\n    si estat_actual \u00e9s l'estat_objectiu:\n      afegir estat_actual a solucions\n    per cada ve\u00ed de estat_actual:\n      si ve\u00ed no est\u00e0 en visitats:\n        afegir ve\u00ed a visitats\n        afegir ve\u00ed a S\n  retornar solucions\n</code></pre>"},{"location":"u03/cerques/#cerca-en-profunditat-limitada","title":"Cerca en profunditat limitada","text":"<p>La cerca en profunditat limitada \u00e9s una variant de la cerca en profunditat que imposa un l\u00edmit a la profunditat m\u00e0xima que es pot explorar. Aix\u00f2 ajuda a evitar caure en cicles infinits i a reduir el temps d'execuci\u00f3 en espais d'estats molt grans. Ara b\u00e9, aquest l\u00edmit pot impedir trobar una soluci\u00f3 si aquesta es troba m\u00e9s enll\u00e0 de la profunditat imposada.</p> <p>La cerca en profunditat limitada \u00e9s \u00fatil quan sabem que la soluci\u00f3 es troba dins d'un cert nombre de passos des de l'estat inicial. El principal desavantatge \u00e9s que si la soluci\u00f3 est\u00e0 m\u00e9s enll\u00e0 del l\u00edmit establert, l'algorisme no la trobar\u00e0.</p> <p>Pseudocodi:</p> <pre><code>Cerca_en_profunditat_limitada(estat_inicial, l\u00edmit):\n  crear pila buida S\n  afegir estat_inicial a S amb profunditat 0\n  mentre S no est\u00e0 buida:\n    (estat_actual, profunditat_actual) = treure de S\n    si estat_actual \u00e9s l'estat_objectiu:\n      retornar el cam\u00ed a estat_actual\n    si profunditat_actual &lt; l\u00edmit:\n      per cada ve\u00ed de estat_actual:\n        si ve\u00ed no est\u00e0 visitat:\n          marcar ve\u00ed com visitat\n          afegir ve\u00ed a S amb profunditat profunditat_actual + 1\n  retornar cap_soluci\u00f3\n</code></pre>"},{"location":"u03/cerques/#cerca-en-profunditat-iterativa","title":"Cerca en profunditat iterativa","text":"<p>La cerca en profunditat iterativa combina els avantatges de la cerca en ampl\u00e0ria i en profunditat. Realitza cerques en profunditat amb l\u00edmits successivament creixents, assegurant que es trobar\u00e0 la soluci\u00f3 m\u00e9s curta.</p> <p>Aquest m\u00e8tode \u00e9s complet i \u00f2ptim com la cerca en ampl\u00e0ria, per\u00f2 amb millors requeriments de mem\u00f2ria. Funciona realitzant repetides cerques en profunditat, incrementant el l\u00edmit de profunditat cada vegada fins que es troba la soluci\u00f3. \u00c9s especialment \u00fatil en espais d'estats molt grans.</p> <p>Pseudocodi:</p> <pre><code>Cerca_en_profunditat_iterativa(estat_inicial):\n  l\u00edmit = 0\n  mentre cert:\n    resultat = Cerca_en_profunditat_limitada(estat_inicial, l\u00edmit)\n    si resultat no \u00e9s cap_soluci\u00f3:\n      retornar resultat\n    l\u00edmit = l\u00edmit + 1\n</code></pre>"},{"location":"u03/cerques/#cerques-informades","title":"Cerques informades","text":"<p>Les cerques informades o heur\u00edstiques utilitzen informaci\u00f3 addicional per guiar la cerca cap a la soluci\u00f3. Aquestes cerques s\u00f3n m\u00e9s eficients que les no informades perqu\u00e8 en lloc d'anar a cegues utilitzen una funci\u00f3 heur\u00edstica que estima el cost o la dist\u00e0ncia des d'un estat donat fins a l'objectiu. Aix\u00f2 permet que l'algorisme es concentre en les branques m\u00e9s prometedores de l'espai d'estats, reduint el nombre de nodes a explorar i millorant l'efici\u00e8ncia de la cerca.</p>"},{"location":"u03/cerques/#que-es-la-heuristica","title":"Qu\u00e8 \u00e9s la heur\u00edstica?","text":"<p>Una heur\u00edstica \u00e9s una funci\u00f3 que estima el cost o la dist\u00e0ncia des d'un estat donat fins a la situaci\u00f3 objectiu. Les cerques heur\u00edstiques utilitzen aquestes funcions per guiar la cerca cap a la soluci\u00f3 de manera m\u00e9s eficient.</p> <p>Les heur\u00edstiques es basen en coneixement addicional sobre el problema (per aix\u00f2 s\u00f3n cerques informades) i poden fer que la cerca siga molt m\u00e9s eficient. Per exemple, en un problema de trobar el cam\u00ed m\u00e9s curt en un mapa, una heur\u00edstica pot ser la dist\u00e0ncia en l\u00ednia recta des de l'estat actual fins a l'objectiu.</p>"},{"location":"u03/cerques/#heuristica-admissible","title":"Heur\u00edstica admissible","text":"<p>Una heur\u00edstica es considera admissible si mai sobreestima el cost de trobar la soluci\u00f3. Aix\u00f2 assegura que la cerca guiada per aquesta heur\u00edstica trobar\u00e0 sempre una soluci\u00f3 \u00f2ptima. Per a qualsevol estat, la funci\u00f3 heur\u00edstica sempre retorna un valor que \u00e9s igual o menor que el cost real d'arribar a l'objectiu. Les heur\u00edstiques admissibles s\u00f3n essencials per garantir que els algorismes de cerca, com A*, troben la millor soluci\u00f3 possible.</p>"},{"location":"u03/cerques/#heuristica-consistent","title":"Heur\u00edstica consistent","text":"<p>Una heur\u00edstica \u00e9s consistent si, per a cada estat, la seua estimaci\u00f3 no excedeix el cost d'arribar a un estat ve\u00ed m\u00e9s el cost estimat des d'aquest estat ve\u00ed fins a la situaci\u00f3 objectiu. Les heur\u00edstiques consistents garanteixen que la cerca A* sigui \u00f2ptima i completa.</p> <p>La consist\u00e8ncia implica que la funci\u00f3 heur\u00edstica h compleix la seg\u00fcent condici\u00f3 per a qualsevol estat n i qualsevol successor n' de n: h(n) &lt;= c(n, n') + h(n'), on c(n, n') \u00e9s el cost d'anar de n a n'. Aquesta propietat assegura que una vegada que un node \u00e9s expandit, el seu cost total no canviar\u00e0.</p>"},{"location":"u03/cerques/#cerca-a","title":"Cerca A*","text":"<p>L'algorisme A* \u00e9s una t\u00e8cnica de cerca heur\u00edstica que utilitza una funci\u00f3 de cost combinada que inclou tant el cost acumulat des de l'inici com l'estimaci\u00f3 heur\u00edstica fins a la situaci\u00f3 objectiu. Aquesta combinaci\u00f3 permet a l'algorisme trobar solucions \u00f2ptimes de manera eficient.</p> <p>A* utilitza una funci\u00f3 de cost f(n) = g(n) + h(n), on g(n) \u00e9s el cost des de l'estat inicial fins a n, i h(n) \u00e9s l'estimaci\u00f3 heur\u00edstica del cost des de n fins a l'objectiu. Aquest algorisme expandeix el node amb el menor valor de f(n), garantint aix\u00ed que trobi el cam\u00ed m\u00e9s curt si h \u00e9s admissible i consistent.</p> <p>Pseudocodi:</p> <pre><code>Cerca_A*(estat_inicial, estat_objectiu, heur\u00edstica):\n  crear cua buida de prioritat Q\n  afegir estat_inicial a Q amb prioritat 0\n  g(estat_inicial) = 0\n  mentre Q no est\u00e0 buida:\n    estat_actual = treure de Q\n    si estat_actual \u00e9s l'estat_objectiu:\n      retornar el cam\u00ed a estat_actual\n    per cada ve\u00ed de estat_actual:\n      cost = g(estat_actual) + cost(estat_actual, ve\u00ed)\n      si ve\u00ed no est\u00e0 en Q o cost &lt; g(ve\u00ed):\n        g(ve\u00ed) = cost\n        f(ve\u00ed) = g(ve\u00ed) + heur\u00edstica(ve\u00ed, estat_objectiu)\n        afegir ve\u00ed a Q amb prioritat f(ve\u00ed)\n  retornar cap_soluci\u00f3\n</code></pre>"},{"location":"u03/cerques/#distancia-de-manhattan","title":"Distancia de Manhattan","text":"<p>La dist\u00e0ncia de Manhattan \u00e9s \u00fatil en problemes on els moviments nom\u00e9s es poden fer en direccions horitzontals i verticals, com en un tauler de joc o un mapa de ciutat.</p> <p>La dist\u00e0ncia Manhattan, tamb\u00e9 coneguda com a \"dist\u00e0ncia taxicab\" o \"dist\u00e0ncia de bloc de ciutat\", es calcula com la suma de les difer\u00e8ncies absolutes entre les coordenades de dos punts en una quadr\u00edcula. \u00c9s \u00fatil quan es pot moure nom\u00e9s horitzontalment i verticalment, com \u00e9s el cas en una ciutat amb carrers ortogonals com Manhattan, d'ah\u00ed el seu nom.</p> <p>En un mapa bidimensional, la dist\u00e0ncia de Manhattan entre dos punts (x1, y1) i (x2, y2) es calcula com |x1 - x2| + |y1 - y2|. Aquesta heur\u00edstica \u00e9s admissible i consistent, ja que sempre subestima el cost real i compleix la condici\u00f3 de consist\u00e8ncia.</p> <p>Aquest c\u00e0lcul es pot generalitzar per a qualsevol dimensi\u00f3, on simplement es sumen les difer\u00e8ncies absolutes de les coordenades corresponents de cada dimensi\u00f3.</p> <p>A difer\u00e8ncia de la dist\u00e0ncia euclidiana, que mesura la dist\u00e0ncia m\u00e9s curta en l\u00ednia recta entre dos punts, la dist\u00e0ncia Manhattan segueix camins paral\u00b7lels a les coordenades, com en un sistema de carrers d'una ciutat. Aquesta dist\u00e0ncia \u00e9s molt utilitzada en aplicacions de ci\u00e8ncies de dades, reconeixement de patrons i en jocs com el \"Snake\", on els moviments s\u00f3n limitats a direccions ortogonals.</p> <p></p>"},{"location":"u03/cerques/#conclusio","title":"Conclusi\u00f3","text":"Algorisme Aplicaci\u00f3 Complexitat Temporal Avantatges Inconvenients BFS (Breadth-First Search) - Cerca en ampl\u00e0ria per grafos no ponderats O(V + E) - Troba el cam\u00ed m\u00e9s curt en grafos no ponderats - No pot manejar grafos ponderats - Detecci\u00f3 de cicles en grafos no dirigits - Simple d'implementar - Pot ser cost\u00f3s en termes de mem\u00f2ria - Cerca de camins m\u00ednims en laberints - Garanteix trobar la soluci\u00f3 m\u00e9s curta en grafos no ponderats - Requereix m\u00e9s mem\u00f2ria que DFS - Generaci\u00f3 d'arbre m\u00ednim en grafos no ponderats DFS (Depth-First Search) - Cerca en profunditat per detectar cicles o components connectats O(V + E) - Menys mem\u00f2ria que BFS - No garanteix cam\u00ed m\u00e9s curt - Ordenaci\u00f3 topol\u00f2gica - Apte per a rec\u00f3rrer tot el grafo - Pot quedar-se en bucles infinits sense mecanismes de prevenci\u00f3 - Cerca en puzzles com el Sudoku o problemes de coloraci\u00f3 - Funciona b\u00e9 amb profunditats limitades - Pot trobar solucions sub\u00f2ptimes en grafos grans - Detecci\u00f3 de connexions fortament connectades Profunditat Iterativa - Cerca combinant els avantatges de DFS i BFS O(b^d), on b \u00e9s el factor de ramificaci\u00f3 i d la profunditat del node - Eficient en espai com DFS, per\u00f2 m\u00e9s complet com BFS - Pot explorar nodes repetidament - Resoluci\u00f3 de problemes on no es coneix la profunditat de la soluci\u00f3 - No requereix estimar la profunditat m\u00e0xima - M\u00e9s lent que BFS per a grafos grans - Cerca de solucions en problemes de jocs (com damuntes o escacs) - Troba solucions en jocs on la profunditat \u00f2ptima no es coneix - Exploraci\u00f3 repetida de nodes A* - Cerca del cam\u00ed \u00f2ptim utilitzant una funci\u00f3 heur\u00edstica O(b^d), on b \u00e9s el factor de ramificaci\u00f3 i d la profunditat del node - Eficient si es tria una bona heur\u00edstica - Dif\u00edcil de definir una heur\u00edstica adequada - Cerca de cam\u00ed m\u00e9s curt en problemes de navegaci\u00f3 - Troba el cam\u00ed m\u00e9s curt si la heur\u00edstica \u00e9s admissible - Pitjor rendiment amb heur\u00edstiques mal dissenyades - Cerca de camins en mapes amb obstacles (per exemple, en robots) - Molt utilitzat en IA i videojocs per trobar el cam\u00ed \u00f2ptim - M\u00e9s cost\u00f3s en termes de c\u00e0lcul que BFS o DFS - Resoluci\u00f3 de problemes de rutes \u00f2ptimes en log\u00edstica"},{"location":"u03/cerques/#llegend","title":"Llegend:","text":"<ul> <li>V: Nombre de nodes (v\u00e8rtexs).</li> <li>E: Nombre d'arestes (arestes).</li> <li>b: Factor de ramificaci\u00f3.</li> <li>d: Profunditat del node objectiu.</li> </ul>"},{"location":"u03/cerques/#cerca-en-planificacio","title":"Cerca en planificaci\u00f3","text":"<p>La cerca en planificaci\u00f3 \u00e9s un enfocament que utilitza algorismes de cerca per resoldre problemes de planificaci\u00f3, on l'objectiu \u00e9s trobar una seq\u00fc\u00e8ncia d'accions que porte a un estat objectiu des d'un estat inicial. Aquest tipus de cerca \u00e9s \u00fatil en \u00e0mbits com la rob\u00f2tica, la log\u00edstica i els jocs, on es requereix una seq\u00fc\u00e8ncia d'accions per assolir un objectiu.</p> <p>La difer\u00e8ncia d'una cerca en planificaci\u00f3 respecte a una cerca en un espai d'estats com les que hem vist \u00e9s que ac\u00ed es busca una seq\u00fc\u00e8ncia d'accions que porte a l'estat objectiu, mentre que en una cerca en un espai d'estats es busca un cam\u00ed entre dos estats. Aix\u00f2 implica que els algorismes de cerca en planificaci\u00f3 han de tenir en compte les accions disponibles i com aquestes afecten l'estat del sistema.</p> <p>En la cerca en planificaci\u00f3 es poden utilitzar diferents algorismes de cerca com els que hem vist anteriorment (BFS, DFS, A*), per\u00f2 adaptats per treballar amb accions i estats.</p>"},{"location":"u03/cerques/#cerca-en-entorns-dincertesa","title":"Cerca en entorns d'incertesa","text":"<p>La cerca en entorns d'incertesa \u00e9s un enfocament que s'utilitza quan els estats del sistema no s\u00f3n totalment coneguts o quan hi ha una certa probabilitat associada a les accions. Aquest tipus de cerca \u00e9s com\u00fa en problemes on les accions poden tenir resultats aleatoris o quan es treballa amb informaci\u00f3 incompleta.</p> <p>En aquests casos, els algorismes de cerca han d'adaptar-se per gestionar la incertesa i prendre decisions basades en probabilitats. Aix\u00f2 pot implicar l'\u00fas de t\u00e8cniques com la programaci\u00f3 din\u00e0mica, els arbres de decisi\u00f3 o els m\u00e8todes de Monte Carlo. Tamb\u00e9 es poden utilitzar algorismes de cerca adaptats per treballar amb entorns estoc\u00e0stics, com el Cerca Minimax o el Cerca Expectimax, que s\u00f3n \u00fatils en jocs i situacions on les accions tenen resultats incerts.</p> <p>En un entorn d'incertesa on la cerca es probabil\u00edstica (les transicions d'estats no s\u00f3n deterministes), pot ser \u00fatil aplicar el Teorema de Bayes per actualitzar les creences sobre l'estat del sistema a mesura que es reben noves observacions. Aix\u00f2 permet ajustar les estrat\u00e8gies de cerca i millorar la presa de decisions en situacions on la informaci\u00f3 \u00e9s incompleta o incerta.</p> <p>Ara aplicarem tots estos conceptes i t\u00e8cniques en la resoluci\u00f3 de problemes pr\u00e0ctics.</p>"}]}